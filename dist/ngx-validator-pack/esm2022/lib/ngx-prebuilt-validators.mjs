/**
 * @license
 * Copyright Slavko Mihajlovic All Rights Reserved.
 *
 * Use of this source code is governed by an ISC-style license that can be
 * found at https://www.isc.org/licenses/
 */
import { regexpMatchValidator, regexpNotAMatchValidator, } from "./ngx-validators";
import { address, dateDD_MM_YYYY, dateYYYY_MM_DD, email, IPAddressV4, IPAddressV4AndV6, IPAddressV6, lettersOnly, noSpecial, numbersOnly, passport, passwordStrength, phoneNumber, singleSpace, spaceRestriction, ssn, timeHH_MM_12, timeHH_MM_24, timeHH_MM_SS_24, url, zipCode, } from "./constant/regex";
/**
 * Checks if a value in the given FromControl / AbstractControl is in a proper address format
 * (Street number Street Name, City, State ZIP code)
 * Example: 3344 W Alameda Avenue, Lakewood, CO 80222
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const addressValidator = (errorName, error) => regexpMatchValidator(address, (errorName = "address"), (error =
    "Please input a value in a format of: Street number Street Name, City, State ZIP code."));
/**
 * Checks if a value in the given FromControl / AbstractControl consists of only
 * alphabetic characters.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const alphabetOnlyValidator = (errorName, error) => regexpMatchValidator(lettersOnly, (errorName = "alphabetOnly"), (error = "Only alphabetic characters are allowed."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in one of the
 * following formats: dd-MM-YYYY, dd.MM.YYYY or dd/MM/YYYY.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const dateDD_MM_YYYYValidator = (errorName, error) => regexpMatchValidator(dateDD_MM_YYYY, (errorName = "dateDD_MM_YYYY"), (error =
    "Please input a value one of the following formats: dd-MM-YYYY or dd.MM.YYYY or dd/MM/YYYY."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a following format:
 * YYYY-MM-dd.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const dateYYYY_MM_DDValidator = (errorName, error) => regexpMatchValidator(dateYYYY_MM_DD, (errorName = "dateYYYY_MM_DD"), (error = "Please input a value in a format: YYYY-MM-dd."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a following format:
 * local-part@domain.com.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const emailValidator = (errorName, error) => regexpMatchValidator(email, (errorName = "email"), (error = "Please input a value in a format: local-part@domain.com."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in one of the
 * following formats: x.x.x.x or y:y:y:y:y:y:y:y.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const ipAddressValidator = (errorName, error) => regexpMatchValidator(IPAddressV4AndV6, (errorName = "ipAddress"), (error =
    "Please input a value one of the following formats: x.x.x.x or y:y:y:y:y:y:y:y"));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a following format:
 * x.x.x.x.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const iPv4Validator = (errorName, error) => regexpMatchValidator(IPAddressV4, (errorName = "iPv4"), (error = "Please input a value in a format: x.x.x.x."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a following format:
 * y:y:y:y:y:y:y:y.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const iPv6Validator = (errorName, error) => regexpMatchValidator(IPAddressV6, (errorName = "iPv6"), (error = "Please input a value in a format: y:y:y:y:y:y:y:y."));
/**
 * Checks if a value in the given FromControl / AbstractControl consists of only
 * numeric characters.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const numericsOnlyValidator = (errorName, error) => regexpMatchValidator(numbersOnly, (errorName = "numericsOnly"), (error = "Only numeric characters are allowed."));
/**
 * Checks if a value in the given FromControl / AbstractControl has any special characters.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const noSpecialsValidator = (errorName, error) => regexpMatchValidator(noSpecial, (errorName = "noSpecials"), (error = "No special characters are allowed."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a proper passport format
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const passportValidator = (errorName, error) => regexpMatchValidator(passport, (errorName = "passport"), (error = "Incorrect passport format."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a strong password format
 * (Has at least 1 lowercase letter, 1 uppercase letter, 1 number, 1 special character and has
 * length of at least 8 characters).
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const passwordValidator = (errorName, error) => regexpMatchValidator(passwordStrength, (errorName = "password"), (error =
    "The value has to contain at least 1 lowercase letter, 1 uppercase letter, 1 special character and has a length of 8."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a following format:
 * (000) 000 0000.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const phoneNumberValidator = (errorName, error) => regexpMatchValidator(phoneNumber, (errorName = "phoneNumber"), (error = "Please input a value in a format: (000) 000 0000."));
/**
 * Checks if a value in the given FromControl / AbstractControl consists of a single space
 * character.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const singleSpaceValidator = (errorName, error) => regexpNotAMatchValidator(singleSpace, (errorName = "singleSpace"), (error = "A single space character is not allowed."));
/**
 * Checks if a value in the given FromControl / AbstractControl starts or ends with a
 * space character.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const spaceRestrictionValidator = (errorName, error) => regexpMatchValidator(spaceRestriction, (errorName = "spaceRestriction"), (error = "Value can not start or end with a space character."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in one of the
 * following formats: AAA-GGG-SSSS or AAAGGGSSSS.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const ssnValidator = (errorName, error) => regexpMatchValidator(ssn, (errorName = "ssn"), (error =
    "Please input a value one of the following formats: AAA-GGG-SSSS or AAAGGGSSSS."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a
 * Time Format HH:MM 12-hour with optional leading 0.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const timeHH_MM_12Validator = (errorName, error) => regexpMatchValidator(timeHH_MM_12, (errorName = "timeHH_MM_12"), (error = "Please input a value in a HH:MM 12-hour format."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a
 * Time Format HH:MM 24-hour with optional leading 0.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const timeHH_MM_24Validator = (errorName, error) => regexpMatchValidator(timeHH_MM_24, (errorName = "timeHH_MM_24"), (error = "Please input a value in a HH:MM 24-hour format."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a
 * Time Format HH:MM:SS 24-hour.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const timeHH_MM_SS_24Validator = (errorName, error) => regexpMatchValidator(timeHH_MM_SS_24, (errorName = "timeHH_MM_SS_24"), (error = "Please input a value in a HH:MM:SS 24-hour format."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a
 * correct url format.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const urlValidator = (errorName, error) => regexpMatchValidator(url, (errorName = "url"), (error = "Improper URL format."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in one of the
 * following formats: 00000 or 00000-0000.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const zipCodeValidator = (errorName, error) => regexpMatchValidator(zipCode, (errorName = "zipCode"), (error = "Improper zip code format."));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXByZWJ1aWx0LXZhbGlkYXRvcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtdmFsaWRhdG9yLXBhY2svc3JjL2xpYi9uZ3gtcHJlYnVpbHQtdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFHSCxPQUFPLEVBQ0wsb0JBQW9CLEVBQ3BCLHdCQUF3QixHQUN6QixNQUFNLGtCQUFrQixDQUFDO0FBQzFCLE9BQU8sRUFDTCxPQUFPLEVBQ1AsY0FBYyxFQUNkLGNBQWMsRUFDZCxLQUFLLEVBQ0wsV0FBVyxFQUNYLGdCQUFnQixFQUNoQixXQUFXLEVBQ1gsV0FBVyxFQUNYLFNBQVMsRUFDVCxXQUFXLEVBQ1gsUUFBUSxFQUNSLGdCQUFnQixFQUNoQixXQUFXLEVBQ1gsV0FBVyxFQUNYLGdCQUFnQixFQUNoQixHQUFHLEVBQ0gsWUFBWSxFQUNaLFlBQVksRUFDWixlQUFlLEVBQ2YsR0FBRyxFQUNILE9BQU8sR0FDUixNQUFNLGtCQUFrQixDQUFDO0FBRTFCOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxDQUM5QixTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLE9BQU8sRUFDUCxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsRUFDdkIsQ0FBQyxLQUFLO0lBQ0osdUZBQXVGLENBQUMsQ0FDM0YsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxxQkFBcUIsR0FBRyxDQUNuQyxTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLFdBQVcsRUFDWCxDQUFDLFNBQVMsR0FBRyxjQUFjLENBQUMsRUFDNUIsQ0FBQyxLQUFLLEdBQUcseUNBQXlDLENBQUMsQ0FDcEQsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSx1QkFBdUIsR0FBRyxDQUNyQyxTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLGNBQWMsRUFDZCxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxFQUM5QixDQUFDLEtBQUs7SUFDSiw0RkFBNEYsQ0FBQyxDQUNoRyxDQUFDO0FBRUo7Ozs7Ozs7R0FPRztBQUNILE1BQU0sQ0FBQyxNQUFNLHVCQUF1QixHQUFHLENBQ3JDLFNBQWtCLEVBQ2xCLEtBQWlDLEVBQ1IsRUFBRSxDQUMzQixvQkFBb0IsQ0FDbEIsY0FBYyxFQUNkLENBQUMsU0FBUyxHQUFHLGdCQUFnQixDQUFDLEVBQzlCLENBQUMsS0FBSyxHQUFHLCtDQUErQyxDQUFDLENBQzFELENBQUM7QUFFSjs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLENBQzVCLFNBQWtCLEVBQ2xCLEtBQWlDLEVBQ1IsRUFBRSxDQUMzQixvQkFBb0IsQ0FDbEIsS0FBSyxFQUNMLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQyxFQUNyQixDQUFDLEtBQUssR0FBRywwREFBMEQsQ0FBQyxDQUNyRSxDQUFDO0FBRUo7Ozs7Ozs7R0FPRztBQUNILE1BQU0sQ0FBQyxNQUFNLGtCQUFrQixHQUFHLENBQ2hDLFNBQWtCLEVBQ2xCLEtBQWlDLEVBQ1IsRUFBRSxDQUMzQixvQkFBb0IsQ0FDbEIsZ0JBQWdCLEVBQ2hCLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQyxFQUN6QixDQUFDLEtBQUs7SUFDSiwrRUFBK0UsQ0FBQyxDQUNuRixDQUFDO0FBRUo7Ozs7Ozs7R0FPRztBQUNILE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxDQUMzQixTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLFdBQVcsRUFDWCxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsRUFDcEIsQ0FBQyxLQUFLLEdBQUcsNENBQTRDLENBQUMsQ0FDdkQsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxhQUFhLEdBQUcsQ0FDM0IsU0FBa0IsRUFDbEIsS0FBaUMsRUFDUixFQUFFLENBQzNCLG9CQUFvQixDQUNsQixXQUFXLEVBQ1gsQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLEVBQ3BCLENBQUMsS0FBSyxHQUFHLG9EQUFvRCxDQUFDLENBQy9ELENBQUM7QUFFSjs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxDQUFDLE1BQU0scUJBQXFCLEdBQUcsQ0FDbkMsU0FBa0IsRUFDbEIsS0FBaUMsRUFDUixFQUFFLENBQzNCLG9CQUFvQixDQUNsQixXQUFXLEVBQ1gsQ0FBQyxTQUFTLEdBQUcsY0FBYyxDQUFDLEVBQzVCLENBQUMsS0FBSyxHQUFHLHNDQUFzQyxDQUFDLENBQ2pELENBQUM7QUFFSjs7Ozs7O0dBTUc7QUFDSCxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBRyxDQUNqQyxTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLFNBQVMsRUFDVCxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUMsRUFDMUIsQ0FBQyxLQUFLLEdBQUcsb0NBQW9DLENBQUMsQ0FDL0MsQ0FBQztBQUVKOzs7Ozs7R0FNRztBQUNILE1BQU0sQ0FBQyxNQUFNLGlCQUFpQixHQUFHLENBQy9CLFNBQWtCLEVBQ2xCLEtBQWlDLEVBQ1IsRUFBRSxDQUMzQixvQkFBb0IsQ0FDbEIsUUFBUSxFQUNSLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQyxFQUN4QixDQUFDLEtBQUssR0FBRyw0QkFBNEIsQ0FBQyxDQUN2QyxDQUFDO0FBRUo7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLENBQUMsTUFBTSxpQkFBaUIsR0FBRyxDQUMvQixTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLGdCQUFnQixFQUNoQixDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUMsRUFDeEIsQ0FBQyxLQUFLO0lBQ0osc0hBQXNILENBQUMsQ0FDMUgsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxvQkFBb0IsR0FBRyxDQUNsQyxTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLFdBQVcsRUFDWCxDQUFDLFNBQVMsR0FBRyxhQUFhLENBQUMsRUFDM0IsQ0FBQyxLQUFLLEdBQUcsbURBQW1ELENBQUMsQ0FDOUQsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxvQkFBb0IsR0FBRyxDQUNsQyxTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isd0JBQXdCLENBQ3RCLFdBQVcsRUFDWCxDQUFDLFNBQVMsR0FBRyxhQUFhLENBQUMsRUFDM0IsQ0FBQyxLQUFLLEdBQUcsMENBQTBDLENBQUMsQ0FDckQsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxDQUN2QyxTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLGdCQUFnQixFQUNoQixDQUFDLFNBQVMsR0FBRyxrQkFBa0IsQ0FBQyxFQUNoQyxDQUFDLEtBQUssR0FBRyxvREFBb0QsQ0FBQyxDQUMvRCxDQUFDO0FBRUo7Ozs7Ozs7R0FPRztBQUNILE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxDQUMxQixTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLEdBQUcsRUFDSCxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsRUFDbkIsQ0FBQyxLQUFLO0lBQ0osZ0ZBQWdGLENBQUMsQ0FDcEYsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxxQkFBcUIsR0FBRyxDQUNuQyxTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLFlBQVksRUFDWixDQUFDLFNBQVMsR0FBRyxjQUFjLENBQUMsRUFDNUIsQ0FBQyxLQUFLLEdBQUcsaURBQWlELENBQUMsQ0FDNUQsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxxQkFBcUIsR0FBRyxDQUNuQyxTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLFlBQVksRUFDWixDQUFDLFNBQVMsR0FBRyxjQUFjLENBQUMsRUFDNUIsQ0FBQyxLQUFLLEdBQUcsaURBQWlELENBQUMsQ0FDNUQsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSx3QkFBd0IsR0FBRyxDQUN0QyxTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLGVBQWUsRUFDZixDQUFDLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxFQUMvQixDQUFDLEtBQUssR0FBRyxvREFBb0QsQ0FBQyxDQUMvRCxDQUFDO0FBRUo7Ozs7Ozs7R0FPRztBQUNILE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxDQUMxQixTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLEdBQUcsRUFDSCxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsRUFDbkIsQ0FBQyxLQUFLLEdBQUcsc0JBQXNCLENBQUMsQ0FDakMsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxDQUM5QixTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0Isb0JBQW9CLENBQ2xCLE9BQU8sRUFDUCxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsRUFDdkIsQ0FBQyxLQUFLLEdBQUcsMkJBQTJCLENBQUMsQ0FDdEMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgU2xhdmtvIE1paGFqbG92aWMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gSVNDLXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgYXQgaHR0cHM6Ly93d3cuaXNjLm9yZy9saWNlbnNlcy9cclxuICovXHJcblxyXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XHJcbmltcG9ydCB7XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IsXHJcbiAgcmVnZXhwTm90QU1hdGNoVmFsaWRhdG9yLFxyXG59IGZyb20gXCIuL25neC12YWxpZGF0b3JzXCI7XHJcbmltcG9ydCB7XHJcbiAgYWRkcmVzcyxcclxuICBkYXRlRERfTU1fWVlZWSxcclxuICBkYXRlWVlZWV9NTV9ERCxcclxuICBlbWFpbCxcclxuICBJUEFkZHJlc3NWNCxcclxuICBJUEFkZHJlc3NWNEFuZFY2LFxyXG4gIElQQWRkcmVzc1Y2LFxyXG4gIGxldHRlcnNPbmx5LFxyXG4gIG5vU3BlY2lhbCxcclxuICBudW1iZXJzT25seSxcclxuICBwYXNzcG9ydCxcclxuICBwYXNzd29yZFN0cmVuZ3RoLFxyXG4gIHBob25lTnVtYmVyLFxyXG4gIHNpbmdsZVNwYWNlLFxyXG4gIHNwYWNlUmVzdHJpY3Rpb24sXHJcbiAgc3NuLFxyXG4gIHRpbWVISF9NTV8xMixcclxuICB0aW1lSEhfTU1fMjQsXHJcbiAgdGltZUhIX01NX1NTXzI0LFxyXG4gIHVybCxcclxuICB6aXBDb2RlLFxyXG59IGZyb20gXCIuL2NvbnN0YW50L3JlZ2V4XCI7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIGEgcHJvcGVyIGFkZHJlc3MgZm9ybWF0XHJcbiAqIChTdHJlZXQgbnVtYmVyIFN0cmVldCBOYW1lLCBDaXR5LCBTdGF0ZSBaSVAgY29kZSlcclxuICogRXhhbXBsZTogMzM0NCBXIEFsYW1lZGEgQXZlbnVlLCBMYWtld29vZCwgQ08gODAyMjJcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGFkZHJlc3NWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cE1hdGNoVmFsaWRhdG9yKFxyXG4gICAgYWRkcmVzcyxcclxuICAgIChlcnJvck5hbWUgPSBcImFkZHJlc3NcIiksXHJcbiAgICAoZXJyb3IgPVxyXG4gICAgICBcIlBsZWFzZSBpbnB1dCBhIHZhbHVlIGluIGEgZm9ybWF0IG9mOiBTdHJlZXQgbnVtYmVyIFN0cmVldCBOYW1lLCBDaXR5LCBTdGF0ZSBaSVAgY29kZS5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBjb25zaXN0cyBvZiBvbmx5XHJcbiAqIGFscGhhYmV0aWMgY2hhcmFjdGVycy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGFscGhhYmV0T25seVZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IoXHJcbiAgICBsZXR0ZXJzT25seSxcclxuICAgIChlcnJvck5hbWUgPSBcImFscGhhYmV0T25seVwiKSxcclxuICAgIChlcnJvciA9IFwiT25seSBhbHBoYWJldGljIGNoYXJhY3RlcnMgYXJlIGFsbG93ZWQuXCIpXHJcbiAgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgaXMgaW4gb25lIG9mIHRoZVxyXG4gKiBmb2xsb3dpbmcgZm9ybWF0czogZGQtTU0tWVlZWSwgZGQuTU0uWVlZWSBvciBkZC9NTS9ZWVlZLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGF0ZUREX01NX1lZWVlWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cE1hdGNoVmFsaWRhdG9yKFxyXG4gICAgZGF0ZUREX01NX1lZWVksXHJcbiAgICAoZXJyb3JOYW1lID0gXCJkYXRlRERfTU1fWVlZWVwiKSxcclxuICAgIChlcnJvciA9XHJcbiAgICAgIFwiUGxlYXNlIGlucHV0IGEgdmFsdWUgb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0czogZGQtTU0tWVlZWSBvciBkZC5NTS5ZWVlZIG9yIGRkL01NL1lZWVkuXCIpXHJcbiAgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgaXMgaW4gYSBmb2xsb3dpbmcgZm9ybWF0OlxyXG4gKiBZWVlZLU1NLWRkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGF0ZVlZWVlfTU1fRERWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cE1hdGNoVmFsaWRhdG9yKFxyXG4gICAgZGF0ZVlZWVlfTU1fREQsXHJcbiAgICAoZXJyb3JOYW1lID0gXCJkYXRlWVlZWV9NTV9ERFwiKSxcclxuICAgIChlcnJvciA9IFwiUGxlYXNlIGlucHV0IGEgdmFsdWUgaW4gYSBmb3JtYXQ6IFlZWVktTU0tZGQuXCIpXHJcbiAgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgaXMgaW4gYSBmb2xsb3dpbmcgZm9ybWF0OlxyXG4gKiBsb2NhbC1wYXJ0QGRvbWFpbi5jb20uXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBlbWFpbFZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IoXHJcbiAgICBlbWFpbCxcclxuICAgIChlcnJvck5hbWUgPSBcImVtYWlsXCIpLFxyXG4gICAgKGVycm9yID0gXCJQbGVhc2UgaW5wdXQgYSB2YWx1ZSBpbiBhIGZvcm1hdDogbG9jYWwtcGFydEBkb21haW4uY29tLlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIG9uZSBvZiB0aGVcclxuICogZm9sbG93aW5nIGZvcm1hdHM6IHgueC54Lnggb3IgeTp5Onk6eTp5Onk6eTp5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaXBBZGRyZXNzVmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBNYXRjaFZhbGlkYXRvcihcclxuICAgIElQQWRkcmVzc1Y0QW5kVjYsXHJcbiAgICAoZXJyb3JOYW1lID0gXCJpcEFkZHJlc3NcIiksXHJcbiAgICAoZXJyb3IgPVxyXG4gICAgICBcIlBsZWFzZSBpbnB1dCBhIHZhbHVlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6IHgueC54Lnggb3IgeTp5Onk6eTp5Onk6eTp5XCIpXHJcbiAgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgaXMgaW4gYSBmb2xsb3dpbmcgZm9ybWF0OlxyXG4gKiB4LngueC54LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaVB2NFZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IoXHJcbiAgICBJUEFkZHJlc3NWNCxcclxuICAgIChlcnJvck5hbWUgPSBcImlQdjRcIiksXHJcbiAgICAoZXJyb3IgPSBcIlBsZWFzZSBpbnB1dCBhIHZhbHVlIGluIGEgZm9ybWF0OiB4LngueC54LlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIGEgZm9sbG93aW5nIGZvcm1hdDpcclxuICogeTp5Onk6eTp5Onk6eTp5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaVB2NlZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IoXHJcbiAgICBJUEFkZHJlc3NWNixcclxuICAgIChlcnJvck5hbWUgPSBcImlQdjZcIiksXHJcbiAgICAoZXJyb3IgPSBcIlBsZWFzZSBpbnB1dCBhIHZhbHVlIGluIGEgZm9ybWF0OiB5Onk6eTp5Onk6eTp5OnkuXCIpXHJcbiAgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgY29uc2lzdHMgb2Ygb25seVxyXG4gKiBudW1lcmljIGNoYXJhY3RlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBudW1lcmljc09ubHlWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cE1hdGNoVmFsaWRhdG9yKFxyXG4gICAgbnVtYmVyc09ubHksXHJcbiAgICAoZXJyb3JOYW1lID0gXCJudW1lcmljc09ubHlcIiksXHJcbiAgICAoZXJyb3IgPSBcIk9ubHkgbnVtZXJpYyBjaGFyYWN0ZXJzIGFyZSBhbGxvd2VkLlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGhhcyBhbnkgc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgbm9TcGVjaWFsc1ZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IoXHJcbiAgICBub1NwZWNpYWwsXHJcbiAgICAoZXJyb3JOYW1lID0gXCJub1NwZWNpYWxzXCIpLFxyXG4gICAgKGVycm9yID0gXCJObyBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGFsbG93ZWQuXCIpXHJcbiAgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgaXMgaW4gYSBwcm9wZXIgcGFzc3BvcnQgZm9ybWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBwYXNzcG9ydFZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IoXHJcbiAgICBwYXNzcG9ydCxcclxuICAgIChlcnJvck5hbWUgPSBcInBhc3Nwb3J0XCIpLFxyXG4gICAgKGVycm9yID0gXCJJbmNvcnJlY3QgcGFzc3BvcnQgZm9ybWF0LlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIGEgc3Ryb25nIHBhc3N3b3JkIGZvcm1hdFxyXG4gKiAoSGFzIGF0IGxlYXN0IDEgbG93ZXJjYXNlIGxldHRlciwgMSB1cHBlcmNhc2UgbGV0dGVyLCAxIG51bWJlciwgMSBzcGVjaWFsIGNoYXJhY3RlciBhbmQgaGFzXHJcbiAqIGxlbmd0aCBvZiBhdCBsZWFzdCA4IGNoYXJhY3RlcnMpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcGFzc3dvcmRWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cE1hdGNoVmFsaWRhdG9yKFxyXG4gICAgcGFzc3dvcmRTdHJlbmd0aCxcclxuICAgIChlcnJvck5hbWUgPSBcInBhc3N3b3JkXCIpLFxyXG4gICAgKGVycm9yID1cclxuICAgICAgXCJUaGUgdmFsdWUgaGFzIHRvIGNvbnRhaW4gYXQgbGVhc3QgMSBsb3dlcmNhc2UgbGV0dGVyLCAxIHVwcGVyY2FzZSBsZXR0ZXIsIDEgc3BlY2lhbCBjaGFyYWN0ZXIgYW5kIGhhcyBhIGxlbmd0aCBvZiA4LlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIGEgZm9sbG93aW5nIGZvcm1hdDpcclxuICogKDAwMCkgMDAwIDAwMDAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBwaG9uZU51bWJlclZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IoXHJcbiAgICBwaG9uZU51bWJlcixcclxuICAgIChlcnJvck5hbWUgPSBcInBob25lTnVtYmVyXCIpLFxyXG4gICAgKGVycm9yID0gXCJQbGVhc2UgaW5wdXQgYSB2YWx1ZSBpbiBhIGZvcm1hdDogKDAwMCkgMDAwIDAwMDAuXCIpXHJcbiAgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgY29uc2lzdHMgb2YgYSBzaW5nbGUgc3BhY2VcclxuICogY2hhcmFjdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc2luZ2xlU3BhY2VWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cE5vdEFNYXRjaFZhbGlkYXRvcihcclxuICAgIHNpbmdsZVNwYWNlLFxyXG4gICAgKGVycm9yTmFtZSA9IFwic2luZ2xlU3BhY2VcIiksXHJcbiAgICAoZXJyb3IgPSBcIkEgc2luZ2xlIHNwYWNlIGNoYXJhY3RlciBpcyBub3QgYWxsb3dlZC5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBzdGFydHMgb3IgZW5kcyB3aXRoIGFcclxuICogc3BhY2UgY2hhcmFjdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3Qgc3BhY2VSZXN0cmljdGlvblZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IoXHJcbiAgICBzcGFjZVJlc3RyaWN0aW9uLFxyXG4gICAgKGVycm9yTmFtZSA9IFwic3BhY2VSZXN0cmljdGlvblwiKSxcclxuICAgIChlcnJvciA9IFwiVmFsdWUgY2FuIG5vdCBzdGFydCBvciBlbmQgd2l0aCBhIHNwYWNlIGNoYXJhY3Rlci5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBvbmUgb2YgdGhlXHJcbiAqIGZvbGxvd2luZyBmb3JtYXRzOiBBQUEtR0dHLVNTU1Mgb3IgQUFBR0dHU1NTUy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNzblZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IoXHJcbiAgICBzc24sXHJcbiAgICAoZXJyb3JOYW1lID0gXCJzc25cIiksXHJcbiAgICAoZXJyb3IgPVxyXG4gICAgICBcIlBsZWFzZSBpbnB1dCBhIHZhbHVlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6IEFBQS1HR0ctU1NTUyBvciBBQUFHR0dTU1NTLlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIGFcclxuICogVGltZSBGb3JtYXQgSEg6TU0gMTItaG91ciB3aXRoIG9wdGlvbmFsIGxlYWRpbmcgMC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHRpbWVISF9NTV8xMlZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IoXHJcbiAgICB0aW1lSEhfTU1fMTIsXHJcbiAgICAoZXJyb3JOYW1lID0gXCJ0aW1lSEhfTU1fMTJcIiksXHJcbiAgICAoZXJyb3IgPSBcIlBsZWFzZSBpbnB1dCBhIHZhbHVlIGluIGEgSEg6TU0gMTItaG91ciBmb3JtYXQuXCIpXHJcbiAgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgaXMgaW4gYVxyXG4gKiBUaW1lIEZvcm1hdCBISDpNTSAyNC1ob3VyIHdpdGggb3B0aW9uYWwgbGVhZGluZyAwLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdGltZUhIX01NXzI0VmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBNYXRjaFZhbGlkYXRvcihcclxuICAgIHRpbWVISF9NTV8yNCxcclxuICAgIChlcnJvck5hbWUgPSBcInRpbWVISF9NTV8yNFwiKSxcclxuICAgIChlcnJvciA9IFwiUGxlYXNlIGlucHV0IGEgdmFsdWUgaW4gYSBISDpNTSAyNC1ob3VyIGZvcm1hdC5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBhXHJcbiAqIFRpbWUgRm9ybWF0IEhIOk1NOlNTIDI0LWhvdXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCB0aW1lSEhfTU1fU1NfMjRWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cE1hdGNoVmFsaWRhdG9yKFxyXG4gICAgdGltZUhIX01NX1NTXzI0LFxyXG4gICAgKGVycm9yTmFtZSA9IFwidGltZUhIX01NX1NTXzI0XCIpLFxyXG4gICAgKGVycm9yID0gXCJQbGVhc2UgaW5wdXQgYSB2YWx1ZSBpbiBhIEhIOk1NOlNTIDI0LWhvdXIgZm9ybWF0LlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIGFcclxuICogY29ycmVjdCB1cmwgZm9ybWF0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdXJsVmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBNYXRjaFZhbGlkYXRvcihcclxuICAgIHVybCxcclxuICAgIChlcnJvck5hbWUgPSBcInVybFwiKSxcclxuICAgIChlcnJvciA9IFwiSW1wcm9wZXIgVVJMIGZvcm1hdC5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBvbmUgb2YgdGhlXHJcbiAqIGZvbGxvd2luZyBmb3JtYXRzOiAwMDAwMCBvciAwMDAwMC0wMDAwLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgemlwQ29kZVZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTWF0Y2hWYWxpZGF0b3IoXHJcbiAgICB6aXBDb2RlLFxyXG4gICAgKGVycm9yTmFtZSA9IFwiemlwQ29kZVwiKSxcclxuICAgIChlcnJvciA9IFwiSW1wcm9wZXIgemlwIGNvZGUgZm9ybWF0LlwiKVxyXG4gICk7XHJcbiJdfQ==