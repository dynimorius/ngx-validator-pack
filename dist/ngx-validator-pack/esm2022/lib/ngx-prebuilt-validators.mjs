/**
 * @license
 * Copyright Slavko Mihajlovic All Rights Reserved.
 *
 * Use of this source code is governed by an ISC-style license that can be
 * found at https://www.isc.org/licenses/
 */
import { regexpValidator, regexpNotValidator, } from "./ngx-validators";
import { address, dateDD_MM_YYYY, dateYYYY_MM_DD, email, IPAddressV4, IPAddressV4AndV6, IPAddressV6, lettersOnly, noSpecial, numbersOnly, passport, passwordStrength, phoneNumber, singleSpace, spaceRestriction, ssn, timeHH_MM_12, timeHH_MM_24, timeHH_MM_SS_24, url, zipCode, } from "./constant/regex";
/**
 * Checks if a value in the given FromControl / AbstractControl is in a proper address format
 * (Street number Street Name, City, State ZIP code)
 * Example: 3344 W Alameda Avenue, Lakewood, CO 80222
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const addressValidator = (errorName, error) => regexpValidator(address, (errorName = "address"), (error =
    "Please input a value in a format of: Street number Street Name, City, State ZIP code."));
/**
 * Checks if a value in the given FromControl / AbstractControl consists of only
 * alphabetic characters.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const alphabetOnlyValidator = (errorName, error) => regexpValidator(lettersOnly, (errorName = "alphabetOnly"), (error = "Only alphabetic characters are allowed."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in one of the
 * following formats: dd-MM-YYYY, dd.MM.YYYY or dd/MM/YYYY.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const dateDD_MM_YYYYValidator = (errorName, error) => regexpValidator(dateDD_MM_YYYY, (errorName = "dateDD_MM_YYYY"), (error =
    "Please input a value one of the following formats: dd-MM-YYYY or dd.MM.YYYY or dd/MM/YYYY."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a following format:
 * YYYY-MM-dd.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const dateYYYY_MM_DDValidator = (errorName, error) => regexpValidator(dateYYYY_MM_DD, (errorName = "dateYYYY_MM_DD"), (error = "Please input a value in a format: YYYY-MM-dd."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a following format:
 * local-part@domain.com.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const emailValidator = (errorName, error) => regexpValidator(email, (errorName = "email"), (error = "Please input a value in a format: local-part@domain.com."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in one of the
 * following formats: x.x.x.x or y:y:y:y:y:y:y:y.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const ipAddressValidator = (errorName, error) => regexpValidator(IPAddressV4AndV6, (errorName = "ipAddress"), (error =
    "Please input a value one of the following formats: x.x.x.x or y:y:y:y:y:y:y:y"));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a following format:
 * x.x.x.x.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const iPv4Validator = (errorName, error) => regexpValidator(IPAddressV4, (errorName = "iPv4"), (error = "Please input a value in a format: x.x.x.x."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a following format:
 * y:y:y:y:y:y:y:y.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const iPv6Validator = (errorName, error) => regexpValidator(IPAddressV6, (errorName = "iPv6"), (error = "Please input a value in a format: y:y:y:y:y:y:y:y."));
/**
 * Checks if a value in the given FromControl / AbstractControl consists of only
 * numeric characters.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const numericsOnlyValidator = (errorName, error) => regexpValidator(numbersOnly, (errorName = "numericsOnly"), (error = "Only numeric characters are allowed."));
/**
 * Checks if a value in the given FromControl / AbstractControl has any special characters.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const noSpecialsValidator = (errorName, error) => regexpValidator(noSpecial, (errorName = "noSpecials"), (error = "No special characters are allowed."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a proper passport format
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const passportValidator = (errorName, error) => regexpValidator(passport, (errorName = "passport"), (error = "Incorrect passport format."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a strong password format
 * (Has at least 1 lowercase letter, 1 uppercase letter, 1 number, 1 special character and has
 * length of at least 8 characters).
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const passwordValidator = (errorName, error) => regexpValidator(passwordStrength, (errorName = "password"), (error =
    "The value has to contain at least 1 lowercase letter, 1 uppercase letter, 1 special character and has a length of 8."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a following format:
 * (000) 000 0000.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const phoneNumberValidator = (errorName, error) => regexpValidator(phoneNumber, (errorName = "phoneNumber"), (error = "Please input a value in a format: (000) 000 0000."));
/**
 * Checks if a value in the given FromControl / AbstractControl consists of a single space
 * character.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const singleSpaceValidator = (errorName, error) => regexpNotValidator(singleSpace, (errorName = "singleSpace"), (error = "A single space character is not allowed."));
/**
 * Checks if a value in the given FromControl / AbstractControl starts or ends with a
 * space character.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const spaceRestrictionValidator = (errorName, error) => regexpValidator(spaceRestriction, (errorName = "spaceRestriction"), (error = "Value can not start or end with a space character."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in one of the
 * following formats: AAA-GGG-SSSS or AAAGGGSSSS.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const ssnValidator = (errorName, error) => regexpValidator(ssn, (errorName = "ssn"), (error =
    "Please input a value one of the following formats: AAA-GGG-SSSS or AAAGGGSSSS."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a
 * Time Format HH:MM 12-hour with optional leading 0.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const timeHH_MM_12Validator = (errorName, error) => regexpValidator(timeHH_MM_12, (errorName = "timeHH_MM_12"), (error = "Please input a value in a HH:MM 12-hour format."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a
 * Time Format HH:MM 24-hour with optional leading 0.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const timeHH_MM_24Validator = (errorName, error) => regexpValidator(timeHH_MM_24, (errorName = "timeHH_MM_24"), (error = "Please input a value in a HH:MM 24-hour format."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a
 * Time Format HH:MM:SS 24-hour.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const timeHH_MM_SS_24Validator = (errorName, error) => regexpValidator(timeHH_MM_SS_24, (errorName = "timeHH_MM_SS_24"), (error = "Please input a value in a HH:MM:SS 24-hour format."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in a
 * correct url format.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const urlValidator = (errorName, error) => regexpValidator(url, (errorName = "url"), (error = "Improper URL format."));
/**
 * Checks if a value in the given FromControl / AbstractControl is in one of the
 * following formats: 00000 or 00000-0000.
 *
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const zipCodeValidator = (errorName, error) => regexpValidator(zipCode, (errorName = "zipCode"), (error = "Improper zip code format."));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXByZWJ1aWx0LXZhbGlkYXRvcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtdmFsaWRhdG9yLXBhY2svc3JjL2xpYi9uZ3gtcHJlYnVpbHQtdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFHSCxPQUFPLEVBQ0wsZUFBZSxFQUNmLGtCQUFrQixHQUNuQixNQUFNLGtCQUFrQixDQUFDO0FBQzFCLE9BQU8sRUFDTCxPQUFPLEVBQ1AsY0FBYyxFQUNkLGNBQWMsRUFDZCxLQUFLLEVBQ0wsV0FBVyxFQUNYLGdCQUFnQixFQUNoQixXQUFXLEVBQ1gsV0FBVyxFQUNYLFNBQVMsRUFDVCxXQUFXLEVBQ1gsUUFBUSxFQUNSLGdCQUFnQixFQUNoQixXQUFXLEVBQ1gsV0FBVyxFQUNYLGdCQUFnQixFQUNoQixHQUFHLEVBQ0gsWUFBWSxFQUNaLFlBQVksRUFDWixlQUFlLEVBQ2YsR0FBRyxFQUNILE9BQU8sR0FDUixNQUFNLGtCQUFrQixDQUFDO0FBRTFCOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxDQUM5QixTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0IsZUFBZSxDQUNiLE9BQU8sRUFDUCxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsRUFDdkIsQ0FBQyxLQUFLO0lBQ0osdUZBQXVGLENBQUMsQ0FDM0YsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxxQkFBcUIsR0FBRyxDQUNuQyxTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0IsZUFBZSxDQUNiLFdBQVcsRUFDWCxDQUFDLFNBQVMsR0FBRyxjQUFjLENBQUMsRUFDNUIsQ0FBQyxLQUFLLEdBQUcseUNBQXlDLENBQUMsQ0FDcEQsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSx1QkFBdUIsR0FB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Q0FDM0IsZUFBZSxDQUNiLFlBQVksRUFDWixDQUFDLFNBQVMsR0FBRyxjQUFjLENBQUMsRUFDNUIsQ0FBQyxLQUFLLEdBQUcsaURBQWlELENBQUMsQ0FDNUQsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSx3QkFBd0IsR0FBRyxDQUN0QyxTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0IsZUFBZSxDQUNiLGVBQWUsRUFDZixDQUFDLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxFQUMvQixDQUFDLEtBQUssR0FBRyxvREFBb0QsQ0FBQyxDQUMvRCxDQUFDO0FBRUo7Ozs7Ozs7R0FPRztBQUNILE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxDQUMxQixTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0IsZUFBZSxDQUNiLEdBQUcsRUFDSCxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsRUFDbkIsQ0FBQyxLQUFLLEdBQUcsc0JBQXNCLENBQUMsQ0FDakMsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxDQUM5QixTQUFrQixFQUNsQixLQUFpQyxFQUNSLEVBQUUsQ0FDM0IsZUFBZSxDQUNiLE9BQU8sRUFDUCxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsRUFDdkIsQ0FBQyxLQUFLLEdBQUcsMkJBQTJCLENBQUMsQ0FDdEMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgU2xhdmtvIE1paGFqbG92aWMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICpcclxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gSVNDLXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcclxuICogZm91bmQgYXQgaHR0cHM6Ly93d3cuaXNjLm9yZy9saWNlbnNlcy9cclxuICovXHJcblxyXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XHJcbmltcG9ydCB7XHJcbiAgcmVnZXhwVmFsaWRhdG9yLFxyXG4gIHJlZ2V4cE5vdFZhbGlkYXRvcixcclxufSBmcm9tIFwiLi9uZ3gtdmFsaWRhdG9yc1wiO1xyXG5pbXBvcnQge1xyXG4gIGFkZHJlc3MsXHJcbiAgZGF0ZUREX01NX1lZWVksXHJcbiAgZGF0ZVlZWVlfTU1fREQsXHJcbiAgZW1haWwsXHJcbiAgSVBBZGRyZXNzVjQsXHJcbiAgSVBBZGRyZXNzVjRBbmRWNixcclxuICBJUEFkZHJlc3NWNixcclxuICBsZXR0ZXJzT25seSxcclxuICBub1NwZWNpYWwsXHJcbiAgbnVtYmVyc09ubHksXHJcbiAgcGFzc3BvcnQsXHJcbiAgcGFzc3dvcmRTdHJlbmd0aCxcclxuICBwaG9uZU51bWJlcixcclxuICBzaW5nbGVTcGFjZSxcclxuICBzcGFjZVJlc3RyaWN0aW9uLFxyXG4gIHNzbixcclxuICB0aW1lSEhfTU1fMTIsXHJcbiAgdGltZUhIX01NXzI0LFxyXG4gIHRpbWVISF9NTV9TU18yNCxcclxuICB1cmwsXHJcbiAgemlwQ29kZSxcclxufSBmcm9tIFwiLi9jb25zdGFudC9yZWdleFwiO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBhIHByb3BlciBhZGRyZXNzIGZvcm1hdFxyXG4gKiAoU3RyZWV0IG51bWJlciBTdHJlZXQgTmFtZSwgQ2l0eSwgU3RhdGUgWklQIGNvZGUpXHJcbiAqIEV4YW1wbGU6IDMzNDQgVyBBbGFtZWRhIEF2ZW51ZSwgTGFrZXdvb2QsIENPIDgwMjIyXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBhZGRyZXNzVmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBWYWxpZGF0b3IoXHJcbiAgICBhZGRyZXNzLFxyXG4gICAgKGVycm9yTmFtZSA9IFwiYWRkcmVzc1wiKSxcclxuICAgIChlcnJvciA9XHJcbiAgICAgIFwiUGxlYXNlIGlucHV0IGEgdmFsdWUgaW4gYSBmb3JtYXQgb2Y6IFN0cmVldCBudW1iZXIgU3RyZWV0IE5hbWUsIENpdHksIFN0YXRlIFpJUCBjb2RlLlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGNvbnNpc3RzIG9mIG9ubHlcclxuICogYWxwaGFiZXRpYyBjaGFyYWN0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYWxwaGFiZXRPbmx5VmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBWYWxpZGF0b3IoXHJcbiAgICBsZXR0ZXJzT25seSxcclxuICAgIChlcnJvck5hbWUgPSBcImFscGhhYmV0T25seVwiKSxcclxuICAgIChlcnJvciA9IFwiT25seSBhbHBoYWJldGljIGNoYXJhY3RlcnMgYXJlIGFsbG93ZWQuXCIpXHJcbiAgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgaXMgaW4gb25lIG9mIHRoZVxyXG4gKiBmb2xsb3dpbmcgZm9ybWF0czogZGQtTU0tWVlZWSwgZGQuTU0uWVlZWSBvciBkZC9NTS9ZWVlZLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGF0ZUREX01NX1lZWVlWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cFZhbGlkYXRvcihcclxuICAgIGRhdGVERF9NTV9ZWVlZLFxyXG4gICAgKGVycm9yTmFtZSA9IFwiZGF0ZUREX01NX1lZWVlcIiksXHJcbiAgICAoZXJyb3IgPVxyXG4gICAgICBcIlBsZWFzZSBpbnB1dCBhIHZhbHVlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6IGRkLU1NLVlZWVkgb3IgZGQuTU0uWVlZWSBvciBkZC9NTS9ZWVlZLlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIGEgZm9sbG93aW5nIGZvcm1hdDpcclxuICogWVlZWS1NTS1kZC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRhdGVZWVlZX01NX0REVmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBWYWxpZGF0b3IoXHJcbiAgICBkYXRlWVlZWV9NTV9ERCxcclxuICAgIChlcnJvck5hbWUgPSBcImRhdGVZWVlZX01NX0REXCIpLFxyXG4gICAgKGVycm9yID0gXCJQbGVhc2UgaW5wdXQgYSB2YWx1ZSBpbiBhIGZvcm1hdDogWVlZWS1NTS1kZC5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBhIGZvbGxvd2luZyBmb3JtYXQ6XHJcbiAqIGxvY2FsLXBhcnRAZG9tYWluLmNvbS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVtYWlsVmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBWYWxpZGF0b3IoXHJcbiAgICBlbWFpbCxcclxuICAgIChlcnJvck5hbWUgPSBcImVtYWlsXCIpLFxyXG4gICAgKGVycm9yID0gXCJQbGVhc2UgaW5wdXQgYSB2YWx1ZSBpbiBhIGZvcm1hdDogbG9jYWwtcGFydEBkb21haW4uY29tLlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIG9uZSBvZiB0aGVcclxuICogZm9sbG93aW5nIGZvcm1hdHM6IHgueC54Lnggb3IgeTp5Onk6eTp5Onk6eTp5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgaXBBZGRyZXNzVmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBWYWxpZGF0b3IoXHJcbiAgICBJUEFkZHJlc3NWNEFuZFY2LFxyXG4gICAgKGVycm9yTmFtZSA9IFwiaXBBZGRyZXNzXCIpLFxyXG4gICAgKGVycm9yID1cclxuICAgICAgXCJQbGVhc2UgaW5wdXQgYSB2YWx1ZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOiB4LngueC54IG9yIHk6eTp5Onk6eTp5Onk6eVwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIGEgZm9sbG93aW5nIGZvcm1hdDpcclxuICogeC54LngueC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlQdjRWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cFZhbGlkYXRvcihcclxuICAgIElQQWRkcmVzc1Y0LFxyXG4gICAgKGVycm9yTmFtZSA9IFwiaVB2NFwiKSxcclxuICAgIChlcnJvciA9IFwiUGxlYXNlIGlucHV0IGEgdmFsdWUgaW4gYSBmb3JtYXQ6IHgueC54LnguXCIpXHJcbiAgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgaXMgaW4gYSBmb2xsb3dpbmcgZm9ybWF0OlxyXG4gKiB5Onk6eTp5Onk6eTp5OnkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBpUHY2VmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBWYWxpZGF0b3IoXHJcbiAgICBJUEFkZHJlc3NWNixcclxuICAgIChlcnJvck5hbWUgPSBcImlQdjZcIiksXHJcbiAgICAoZXJyb3IgPSBcIlBsZWFzZSBpbnB1dCBhIHZhbHVlIGluIGEgZm9ybWF0OiB5Onk6eTp5Onk6eTp5OnkuXCIpXHJcbiAgKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgY29uc2lzdHMgb2Ygb25seVxyXG4gKiBudW1lcmljIGNoYXJhY3RlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBudW1lcmljc09ubHlWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cFZhbGlkYXRvcihcclxuICAgIG51bWJlcnNPbmx5LFxyXG4gICAgKGVycm9yTmFtZSA9IFwibnVtZXJpY3NPbmx5XCIpLFxyXG4gICAgKGVycm9yID0gXCJPbmx5IG51bWVyaWMgY2hhcmFjdGVycyBhcmUgYWxsb3dlZC5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBoYXMgYW55IHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IG5vU3BlY2lhbHNWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cFZhbGlkYXRvcihcclxuICAgIG5vU3BlY2lhbCxcclxuICAgIChlcnJvck5hbWUgPSBcIm5vU3BlY2lhbHNcIiksXHJcbiAgICAoZXJyb3IgPSBcIk5vIHNwZWNpYWwgY2hhcmFjdGVycyBhcmUgYWxsb3dlZC5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBhIHByb3BlciBwYXNzcG9ydCBmb3JtYXRcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHBhc3Nwb3J0VmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBWYWxpZGF0b3IoXHJcbiAgICBwYXNzcG9ydCxcclxuICAgIChlcnJvck5hbWUgPSBcInBhc3Nwb3J0XCIpLFxyXG4gICAgKGVycm9yID0gXCJJbmNvcnJlY3QgcGFzc3BvcnQgZm9ybWF0LlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIGEgc3Ryb25nIHBhc3N3b3JkIGZvcm1hdFxyXG4gKiAoSGFzIGF0IGxlYXN0IDEgbG93ZXJjYXNlIGxldHRlciwgMSB1cHBlcmNhc2UgbGV0dGVyLCAxIG51bWJlciwgMSBzcGVjaWFsIGNoYXJhY3RlciBhbmQgaGFzXHJcbiAqIGxlbmd0aCBvZiBhdCBsZWFzdCA4IGNoYXJhY3RlcnMpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcGFzc3dvcmRWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cFZhbGlkYXRvcihcclxuICAgIHBhc3N3b3JkU3RyZW5ndGgsXHJcbiAgICAoZXJyb3JOYW1lID0gXCJwYXNzd29yZFwiKSxcclxuICAgIChlcnJvciA9XHJcbiAgICAgIFwiVGhlIHZhbHVlIGhhcyB0byBjb250YWluIGF0IGxlYXN0IDEgbG93ZXJjYXNlIGxldHRlciwgMSB1cHBlcmNhc2UgbGV0dGVyLCAxIHNwZWNpYWwgY2hhcmFjdGVyIGFuZCBoYXMgYSBsZW5ndGggb2YgOC5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBhIGZvbGxvd2luZyBmb3JtYXQ6XHJcbiAqICgwMDApIDAwMCAwMDAwLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgcGhvbmVOdW1iZXJWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cFZhbGlkYXRvcihcclxuICAgIHBob25lTnVtYmVyLFxyXG4gICAgKGVycm9yTmFtZSA9IFwicGhvbmVOdW1iZXJcIiksXHJcbiAgICAoZXJyb3IgPSBcIlBsZWFzZSBpbnB1dCBhIHZhbHVlIGluIGEgZm9ybWF0OiAoMDAwKSAwMDAgMDAwMC5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBjb25zaXN0cyBvZiBhIHNpbmdsZSBzcGFjZVxyXG4gKiBjaGFyYWN0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBzaW5nbGVTcGFjZVZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwTm90VmFsaWRhdG9yKFxyXG4gICAgc2luZ2xlU3BhY2UsXHJcbiAgICAoZXJyb3JOYW1lID0gXCJzaW5nbGVTcGFjZVwiKSxcclxuICAgIChlcnJvciA9IFwiQSBzaW5nbGUgc3BhY2UgY2hhcmFjdGVyIGlzIG5vdCBhbGxvd2VkLlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIHN0YXJ0cyBvciBlbmRzIHdpdGggYVxyXG4gKiBzcGFjZSBjaGFyYWN0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBzcGFjZVJlc3RyaWN0aW9uVmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBWYWxpZGF0b3IoXHJcbiAgICBzcGFjZVJlc3RyaWN0aW9uLFxyXG4gICAgKGVycm9yTmFtZSA9IFwic3BhY2VSZXN0cmljdGlvblwiKSxcclxuICAgIChlcnJvciA9IFwiVmFsdWUgY2FuIG5vdCBzdGFydCBvciBlbmQgd2l0aCBhIHNwYWNlIGNoYXJhY3Rlci5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBvbmUgb2YgdGhlXHJcbiAqIGZvbGxvd2luZyBmb3JtYXRzOiBBQUEtR0dHLVNTU1Mgb3IgQUFBR0dHU1NTUy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHNzblZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwVmFsaWRhdG9yKFxyXG4gICAgc3NuLFxyXG4gICAgKGVycm9yTmFtZSA9IFwic3NuXCIpLFxyXG4gICAgKGVycm9yID1cclxuICAgICAgXCJQbGVhc2UgaW5wdXQgYSB2YWx1ZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOiBBQUEtR0dHLVNTU1Mgb3IgQUFBR0dHU1NTUy5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBhXHJcbiAqIFRpbWUgRm9ybWF0IEhIOk1NIDEyLWhvdXIgd2l0aCBvcHRpb25hbCBsZWFkaW5nIDAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCB0aW1lSEhfTU1fMTJWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cFZhbGlkYXRvcihcclxuICAgIHRpbWVISF9NTV8xMixcclxuICAgIChlcnJvck5hbWUgPSBcInRpbWVISF9NTV8xMlwiKSxcclxuICAgIChlcnJvciA9IFwiUGxlYXNlIGlucHV0IGEgdmFsdWUgaW4gYSBISDpNTSAxMi1ob3VyIGZvcm1hdC5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBhXHJcbiAqIFRpbWUgRm9ybWF0IEhIOk1NIDI0LWhvdXIgd2l0aCBvcHRpb25hbCBsZWFkaW5nIDAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCB0aW1lSEhfTU1fMjRWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cFZhbGlkYXRvcihcclxuICAgIHRpbWVISF9NTV8yNCxcclxuICAgIChlcnJvck5hbWUgPSBcInRpbWVISF9NTV8yNFwiKSxcclxuICAgIChlcnJvciA9IFwiUGxlYXNlIGlucHV0IGEgdmFsdWUgaW4gYSBISDpNTSAyNC1ob3VyIGZvcm1hdC5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBhXHJcbiAqIFRpbWUgRm9ybWF0IEhIOk1NOlNTIDI0LWhvdXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCB0aW1lSEhfTU1fU1NfMjRWYWxpZGF0b3IgPSAoXHJcbiAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gIGVycm9yPzogVmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ1xyXG4pOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PlxyXG4gIHJlZ2V4cFZhbGlkYXRvcihcclxuICAgIHRpbWVISF9NTV9TU18yNCxcclxuICAgIChlcnJvck5hbWUgPSBcInRpbWVISF9NTV9TU18yNFwiKSxcclxuICAgIChlcnJvciA9IFwiUGxlYXNlIGlucHV0IGEgdmFsdWUgaW4gYSBISDpNTTpTUyAyNC1ob3VyIGZvcm1hdC5cIilcclxuICApO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGluIHRoZSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBpcyBpbiBhXHJcbiAqIGNvcnJlY3QgdXJsIGZvcm1hdC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHVybFZhbGlkYXRvciA9IChcclxuICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbik6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+XHJcbiAgcmVnZXhwVmFsaWRhdG9yKFxyXG4gICAgdXJsLFxyXG4gICAgKGVycm9yTmFtZSA9IFwidXJsXCIpLFxyXG4gICAgKGVycm9yID0gXCJJbXByb3BlciBVUkwgZm9ybWF0LlwiKVxyXG4gICk7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGluIG9uZSBvZiB0aGVcclxuICogZm9sbG93aW5nIGZvcm1hdHM6IDAwMDAwIG9yIDAwMDAwLTAwMDAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCB6aXBDb2RlVmFsaWRhdG9yID0gKFxyXG4gIGVycm9yTmFtZT86IHN0cmluZyxcclxuICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT5cclxuICByZWdleHBWYWxpZGF0b3IoXHJcbiAgICB6aXBDb2RlLFxyXG4gICAgKGVycm9yTmFtZSA9IFwiemlwQ29kZVwiKSxcclxuICAgIChlcnJvciA9IFwiSW1wcm9wZXIgemlwIGNvZGUgZm9ybWF0LlwiKVxyXG4gICk7XHJcbiJdfQ==