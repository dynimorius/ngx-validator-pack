/**
 * @license
 * Copyright Slavko Mihajlovic All Rights Reserved.
 *
 * Use of this source code is governed by an ISC-style license that can be
 * found at https://www.isc.org/licenses/
 */
import { compareDates, prepareToCompare, } from "./helpers/date";
/**
 * Preforms a RegEx check on value in the given FromControl / AbstractControl
 *
 * @param {RegExp}                    - Regular expression to check
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const regexpValidator = (regexp, errorName, error) => (control) => {
    error = error || "This control did not match a given regular expression.";
    const errors = typeof error === "string"
        ? { [errorName ?? "regexpValidator"]: error }
        : error;
    return !control.value || regexp.test(control.value) ? null : errors;
};
/**
 * Preforms a RegEx check on value in the given FromControl / AbstractControl
 *
 * @param {RegExp}                    - Regular expression to check
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const regexpNotValidator = (regexp, errorName, error) => (control) => {
    error = error || "This control matched a given regular expression.";
    const errors = typeof error === "string"
        ? { [errorName ?? "regexpValidator"]: error }
        : error;
    return !control.value || !regexp.test(control.value) ? null : errors;
};
/**
 * Checks if the date in the given FromControl / AbstractControl is earlier then
 * the value in the specified FromControl / AbstractControl
 *
 * @param {AbstractControl}           - AbstractControl to preform the check against
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const earlierThenValidator = (date, errorName, error) => (control) => {
    error = error || `This control must have a value earlier then ${date}.`;
    const errors = typeof error === "string"
        ? { [errorName ?? "earlierThen"]: error }
        : error;
    return prepareToCompare(control?.value) < prepareToCompare(date)
        ? null
        : errors;
};
/**
 * Checks if the date in the given FromControl / AbstractControl is greater then
 * the value in the specified FromControl / AbstractControl
 *
 * @param {AbstractControl}           - AbstractControl to preform the check against
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const laterThenValidator = (date, errorName, error) => (control) => {
    error = error || `This control must have a value later then ${date}.`;
    const errors = typeof error === "string" ? { [errorName ?? "laterThen"]: error } : error;
    return prepareToCompare(control?.value) > prepareToCompare(date)
        ? null
        : errors;
};
/**
 * Compares the date values of the given FromControl / AbstractControl and
 * specified FromControl / AbstractControl
 *
 * @param {string}                    - name of the filed to compare against
 * @param {ComparisonOperations}      - comparison to preform
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const compareToValidator = (filedName, comparison, errorName, error) => (control) => {
    const date = control.parent?.get(filedName)?.value;
    if (date) {
        error = error || `Value comparison with ${date} failed.`;
        const errors = typeof error === "string"
            ? { [errorName ?? "dateComparison"]: error }
            : error;
        return control.value && compareDates(control.value, date, comparison)
            ? null
            : errors;
    }
    return null;
};
/**
 * Returns a validation error if a condition is met
 *
 * @param {Function | boolean}        - conditional function or a boolean value
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const requiredWhenValidator = (conditional, errorName, error) => (control) => {
    error = error || "This control has a conditional set on it.";
    const errors = typeof error === "string"
        ? { [errorName ?? "requiredWhen"]: error }
        : error;
    const outcome = typeof conditional === "function" ? conditional() : conditional;
    return !control.value && outcome ? errors : null;
};
/**
 * Returns a validation error if a given FromControl / AbstractControl has no value
 * and specified FromControl / AbstractControl has it
 *
 * @param {string}                    - name of the FromControl / AbstractControl to link to
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const linkToValidator = (linkTo, errorName, error) => (control) => {
    error = error || `This control has a link to ${linkTo}.`;
    const errors = typeof error === "string" ? { [errorName ?? "linkTo"]: error } : error;
    const linkedTo = control.parent?.get(linkTo);
    return !control?.value && !!linkedTo?.value ? errors : null;
};
/**
 * Returns a validation error if a given FromControl / AbstractControl has a value
 * and specified FromControl / AbstractControl does not
 *
 * @param {string}                    - name of the FromControl / AbstractControl
 *                                      which a given FromControl / AbstractControl is linked to
 * @param {string}                    - optional parameter representing error name
 * @param {ValidationErrors | string} - optional parameter representing error value
 * @returns {ValidationErrors | null} - Validation error
 */
export const linkedToValidator = (linkedTo, errorName, error) => (control) => {
    error = error || `This control is linked to ${linkedTo}.`;
    const errors = typeof error === "string" ? { [errorName ?? "linkTo"]: error } : error;
    const link = control.parent?.get(linkedTo);
    return !!control?.value && !link?.value ? errors : null;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXZhbGlkYXRvcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtdmFsaWRhdG9yLXBhY2svc3JjL2xpYi9uZ3gtdmFsaWRhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFHSCxPQUFPLEVBQ0wsWUFBWSxFQUVaLGdCQUFnQixHQUNqQixNQUFNLGdCQUFnQixDQUFDO0FBRXhCOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxlQUFlLEdBQzFCLENBQ0UsTUFBYyxFQUNkLFNBQWtCLEVBQ2xCLEtBQWlDLEVBQ3BCLEVBQUUsQ0FDakIsQ0FBQyxPQUF3QixFQUEyQixFQUFFO0lBQ3BELEtBQUssR0FBRyxLQUFLLElBQUksd0RBQXdELENBQUM7SUFDMUUsTUFBTSxNQUFNLEdBQ1YsT0FBTyxLQUFLLEtBQUssUUFBUTtRQUN2QixDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsSUFBSSxpQkFBaUIsQ0FBQyxFQUFFLEtBQUssRUFBRTtRQUM3QyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBRVosT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ3RFLENBQUMsQ0FBQztBQUVKOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FDN0IsQ0FDRSxNQUFjLEVBQ2QsU0FBa0IsRUFDbEIsS0FBaUMsRUFDcEIsRUFBRSxDQUNqQixDQUFDLE9BQXdCLEVBQTJCLEVBQUU7SUFDcEQsS0FBSyxHQUFHLEtBQUssSUFBSSxrREFBa0QsQ0FBQztJQUNwRSxNQUFNLE1BQU0sR0FDVixPQUFPLEtBQUssS0FBSyxRQUFRO1FBQ3ZCLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxJQUFJLGlCQUFpQixDQUFD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QixFQUEyQixFQUFFO0lBQ3BELEtBQUssR0FBRyxLQUFLLElBQUksNkJBQTZCLFFBQVEsR0FBRyxDQUFDO0lBQzFELE1BQU0sTUFBTSxHQUNWLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsSUFBSSxRQUFRLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBRXpFLE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzNDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUMxRCxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IFNsYXZrbyBNaWhhamxvdmljIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIElTQy1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXHJcbiAqIGZvdW5kIGF0IGh0dHBzOi8vd3d3LmlzYy5vcmcvbGljZW5zZXMvXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3JGbiB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xyXG5pbXBvcnQge1xyXG4gIGNvbXBhcmVEYXRlcyxcclxuICBDb21wYXJpc29uT3BlcmF0aW9ucyxcclxuICBwcmVwYXJlVG9Db21wYXJlLFxyXG59IGZyb20gXCIuL2hlbHBlcnMvZGF0ZVwiO1xyXG5cclxuLyoqXHJcbiAqIFByZWZvcm1zIGEgUmVnRXggY2hlY2sgb24gdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSAgICAgICAgICAgICAgICAgICAgLSBSZWd1bGFyIGV4cHJlc3Npb24gdG8gY2hlY2tcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlZ2V4cFZhbGlkYXRvciA9XHJcbiAgKFxyXG4gICAgcmVnZXhwOiBSZWdFeHAsXHJcbiAgICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuICApOiBWYWxpZGF0b3JGbiA9PlxyXG4gIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XHJcbiAgICBlcnJvciA9IGVycm9yIHx8IFwiVGhpcyBjb250cm9sIGRpZCBub3QgbWF0Y2ggYSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uXCI7XHJcbiAgICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcnMgPVxyXG4gICAgICB0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCJcclxuICAgICAgICA/IHsgW2Vycm9yTmFtZSA/PyBcInJlZ2V4cFZhbGlkYXRvclwiXTogZXJyb3IgfVxyXG4gICAgICAgIDogZXJyb3I7XHJcblxyXG4gICAgcmV0dXJuICFjb250cm9sLnZhbHVlIHx8IHJlZ2V4cC50ZXN0KGNvbnRyb2wudmFsdWUpID8gbnVsbCA6IGVycm9ycztcclxuICB9O1xyXG5cclxuLyoqXHJcbiAqIFByZWZvcm1zIGEgUmVnRXggY2hlY2sgb24gdmFsdWUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVnRXhwfSAgICAgICAgICAgICAgICAgICAgLSBSZWd1bGFyIGV4cHJlc3Npb24gdG8gY2hlY2tcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJlZ2V4cE5vdFZhbGlkYXRvciA9XHJcbiAgKFxyXG4gICAgcmVnZXhwOiBSZWdFeHAsXHJcbiAgICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuICApOiBWYWxpZGF0b3JGbiA9PlxyXG4gIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XHJcbiAgICBlcnJvciA9IGVycm9yIHx8IFwiVGhpcyBjb250cm9sIG1hdGNoZWQgYSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uXCI7XHJcbiAgICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcnMgPVxyXG4gICAgICB0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCJcclxuICAgICAgICA/IHsgW2Vycm9yTmFtZSA/PyBcInJlZ2V4cFZhbGlkYXRvclwiXTogZXJyb3IgfVxyXG4gICAgICAgIDogZXJyb3I7XHJcblxyXG4gICAgcmV0dXJuICFjb250cm9sLnZhbHVlIHx8ICFyZWdleHAudGVzdChjb250cm9sLnZhbHVlKSA/IG51bGwgOiBlcnJvcnM7XHJcbiAgfTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIGRhdGUgaW4gdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGVhcmxpZXIgdGhlblxyXG4gKiB0aGUgdmFsdWUgaW4gdGhlIHNwZWNpZmllZCBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbFxyXG4gKlxyXG4gKiBAcGFyYW0ge0Fic3RyYWN0Q29udHJvbH0gICAgICAgICAgIC0gQWJzdHJhY3RDb250cm9sIHRvIHByZWZvcm0gdGhlIGNoZWNrIGFnYWluc3RcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGVhcmxpZXJUaGVuVmFsaWRhdG9yID1cclxuICAoXHJcbiAgICBkYXRlOiBEYXRlLFxyXG4gICAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gICAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbiAgKTogVmFsaWRhdG9yRm4gPT5cclxuICAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xyXG4gICAgZXJyb3IgPSBlcnJvciB8fCBgVGhpcyBjb250cm9sIG11c3QgaGF2ZSBhIHZhbHVlIGVhcmxpZXIgdGhlbiAke2RhdGV9LmA7XHJcbiAgICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcnMgPVxyXG4gICAgICB0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCJcclxuICAgICAgICA/IHsgW2Vycm9yTmFtZSA/PyBcImVhcmxpZXJUaGVuXCJdOiBlcnJvciB9XHJcbiAgICAgICAgOiBlcnJvcjtcclxuXHJcbiAgICByZXR1cm4gcHJlcGFyZVRvQ29tcGFyZShjb250cm9sPy52YWx1ZSkgPCBwcmVwYXJlVG9Db21wYXJlKGRhdGUpXHJcbiAgICAgID8gbnVsbFxyXG4gICAgICA6IGVycm9ycztcclxuICB9O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGUgZGF0ZSBpbiB0aGUgZ2l2ZW4gRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgaXMgZ3JlYXRlciB0aGVuXHJcbiAqIHRoZSB2YWx1ZSBpbiB0aGUgc3BlY2lmaWVkIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sXHJcbiAqXHJcbiAqIEBwYXJhbSB7QWJzdHJhY3RDb250cm9sfSAgICAgICAgICAgLSBBYnN0cmFjdENvbnRyb2wgdG8gcHJlZm9ybSB0aGUgY2hlY2sgYWdhaW5zdFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGF0ZXJUaGVuVmFsaWRhdG9yID1cclxuICAoXHJcbiAgICBkYXRlOiBEYXRlLFxyXG4gICAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gICAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbiAgKTogVmFsaWRhdG9yRm4gPT5cclxuICAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xyXG4gICAgZXJyb3IgPSBlcnJvciB8fCBgVGhpcyBjb250cm9sIG11c3QgaGF2ZSBhIHZhbHVlIGxhdGVyIHRoZW4gJHtkYXRlfS5gO1xyXG4gICAgY29uc3QgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JzID1cclxuICAgICAgdHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiID8geyBbZXJyb3JOYW1lID8/IFwibGF0ZXJUaGVuXCJdOiBlcnJvciB9IDogZXJyb3I7XHJcblxyXG4gICAgcmV0dXJuIHByZXBhcmVUb0NvbXBhcmUoY29udHJvbD8udmFsdWUpID4gcHJlcGFyZVRvQ29tcGFyZShkYXRlKVxyXG4gICAgICA/IG51bGxcclxuICAgICAgOiBlcnJvcnM7XHJcbiAgfTtcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0aGUgZGF0ZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGFuZFxyXG4gKiBzcGVjaWZpZWQgRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2xcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG5hbWUgb2YgdGhlIGZpbGVkIHRvIGNvbXBhcmUgYWdhaW5zdFxyXG4gKiBAcGFyYW0ge0NvbXBhcmlzb25PcGVyYXRpb25zfSAgICAgIC0gY29tcGFyaXNvbiB0byBwcmVmb3JtXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCBjb21wYXJlVG9WYWxpZGF0b3IgPVxyXG4gIChcclxuICAgIGZpbGVkTmFtZTogc3RyaW5nLFxyXG4gICAgY29tcGFyaXNvbjogQ29tcGFyaXNvbk9wZXJhdGlvbnMsXHJcbiAgICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuICApOiBWYWxpZGF0b3JGbiA9PlxyXG4gIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XHJcbiAgICBjb25zdCBkYXRlID0gY29udHJvbC5wYXJlbnQ/LmdldChmaWxlZE5hbWUpPy52YWx1ZTtcclxuICAgIGlmIChkYXRlKSB7XHJcbiAgICAgIGVycm9yID0gZXJyb3IgfHwgYFZhbHVlIGNvbXBhcmlzb24gd2l0aCAke2RhdGV9IGZhaWxlZC5gO1xyXG4gICAgICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcnMgPVxyXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIlxyXG4gICAgICAgICAgPyB7IFtlcnJvck5hbWUgPz8gXCJkYXRlQ29tcGFyaXNvblwiXTogZXJyb3IgfVxyXG4gICAgICAgICAgOiBlcnJvcjtcclxuICAgICAgcmV0dXJuIGNvbnRyb2wudmFsdWUgJiYgY29tcGFyZURhdGVzKGNvbnRyb2wudmFsdWUsIGRhdGUsIGNvbXBhcmlzb24pXHJcbiAgICAgICAgPyBudWxsXHJcbiAgICAgICAgOiBlcnJvcnM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSB2YWxpZGF0aW9uIGVycm9yIGlmIGEgY29uZGl0aW9uIGlzIG1ldFxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9uIHwgYm9vbGVhbn0gICAgICAgIC0gY29uZGl0aW9uYWwgZnVuY3Rpb24gb3IgYSBib29sZWFuIHZhbHVlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgICAgLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIG5hbWVcclxuICogQHBhcmFtIHtWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nfSAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgdmFsdWVcclxuICogQHJldHVybnMge1ZhbGlkYXRpb25FcnJvcnMgfCBudWxsfSAtIFZhbGlkYXRpb24gZXJyb3JcclxuICovXHJcbmV4cG9ydCBjb25zdCByZXF1aXJlZFdoZW5WYWxpZGF0b3IgPVxyXG4gIChcclxuICAgIGNvbmRpdGlvbmFsOiAoKCkgPT4gYm9vbGVhbikgfCBib29sZWFuLFxyXG4gICAgZXJyb3JOYW1lPzogc3RyaW5nLFxyXG4gICAgZXJyb3I/OiBWYWxpZGF0aW9uRXJyb3JzIHwgc3RyaW5nXHJcbiAgKTogVmFsaWRhdG9yRm4gPT5cclxuICAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xyXG4gICAgZXJyb3IgPSBlcnJvciB8fCBcIlRoaXMgY29udHJvbCBoYXMgYSBjb25kaXRpb25hbCBzZXQgb24gaXQuXCI7XHJcbiAgICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcnMgPVxyXG4gICAgICB0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCJcclxuICAgICAgICA/IHsgW2Vycm9yTmFtZSA/PyBcInJlcXVpcmVkV2hlblwiXTogZXJyb3IgfVxyXG4gICAgICAgIDogZXJyb3I7XHJcblxyXG4gICAgY29uc3Qgb3V0Y29tZSA9XHJcbiAgICAgIHR5cGVvZiBjb25kaXRpb25hbCA9PT0gXCJmdW5jdGlvblwiID8gY29uZGl0aW9uYWwoKSA6IGNvbmRpdGlvbmFsO1xyXG4gICAgcmV0dXJuICFjb250cm9sLnZhbHVlICYmIG91dGNvbWUgPyBlcnJvcnMgOiBudWxsO1xyXG4gIH07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHZhbGlkYXRpb24gZXJyb3IgaWYgYSBnaXZlbiBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBoYXMgbm8gdmFsdWVcclxuICogYW5kIHNwZWNpZmllZCBGcm9tQ29udHJvbCAvIEFic3RyYWN0Q29udHJvbCBoYXMgaXRcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG5hbWUgb2YgdGhlIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIHRvIGxpbmsgdG9cclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG9wdGlvbmFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgZXJyb3IgbmFtZVxyXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmd9IC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7VmFsaWRhdGlvbkVycm9ycyB8IG51bGx9IC0gVmFsaWRhdGlvbiBlcnJvclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGxpbmtUb1ZhbGlkYXRvciA9XHJcbiAgKFxyXG4gICAgbGlua1RvOiBzdHJpbmcsXHJcbiAgICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuICApOiBWYWxpZGF0b3JGbiA9PlxyXG4gIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XHJcbiAgICBlcnJvciA9IGVycm9yIHx8IGBUaGlzIGNvbnRyb2wgaGFzIGEgbGluayB0byAke2xpbmtUb30uYDtcclxuICAgIGNvbnN0IGVycm9yczogVmFsaWRhdGlvbkVycm9ycyA9XHJcbiAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiA/IHsgW2Vycm9yTmFtZSA/PyBcImxpbmtUb1wiXTogZXJyb3IgfSA6IGVycm9yO1xyXG5cclxuICAgIGNvbnN0IGxpbmtlZFRvID0gY29udHJvbC5wYXJlbnQ/LmdldChsaW5rVG8pO1xyXG4gICAgcmV0dXJuICFjb250cm9sPy52YWx1ZSAmJiAhIWxpbmtlZFRvPy52YWx1ZSA/IGVycm9ycyA6IG51bGw7XHJcbiAgfTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdmFsaWRhdGlvbiBlcnJvciBpZiBhIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGhhcyBhIHZhbHVlXHJcbiAqIGFuZCBzcGVjaWZpZWQgRnJvbUNvbnRyb2wgLyBBYnN0cmFjdENvbnRyb2wgZG9lcyBub3RcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICAgICAtIG5hbWUgb2YgdGhlIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCBhIGdpdmVuIEZyb21Db250cm9sIC8gQWJzdHJhY3RDb250cm9sIGlzIGxpbmtlZCB0b1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICAgIC0gb3B0aW9uYWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBlcnJvciBuYW1lXHJcbiAqIEBwYXJhbSB7VmFsaWRhdGlvbkVycm9ycyB8IHN0cmluZ30gLSBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGVycm9yIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbH0gLSBWYWxpZGF0aW9uIGVycm9yXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgbGlua2VkVG9WYWxpZGF0b3IgPVxyXG4gIChcclxuICAgIGxpbmtlZFRvOiBzdHJpbmcsXHJcbiAgICBlcnJvck5hbWU/OiBzdHJpbmcsXHJcbiAgICBlcnJvcj86IFZhbGlkYXRpb25FcnJvcnMgfCBzdHJpbmdcclxuICApOiBWYWxpZGF0b3JGbiA9PlxyXG4gIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XHJcbiAgICBlcnJvciA9IGVycm9yIHx8IGBUaGlzIGNvbnRyb2wgaXMgbGlua2VkIHRvICR7bGlua2VkVG99LmA7XHJcbiAgICBjb25zdCBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcnMgPVxyXG4gICAgICB0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIgPyB7IFtlcnJvck5hbWUgPz8gXCJsaW5rVG9cIl06IGVycm9yIH0gOiBlcnJvcjtcclxuXHJcbiAgICBjb25zdCBsaW5rID0gY29udHJvbC5wYXJlbnQ/LmdldChsaW5rZWRUbyk7XHJcbiAgICByZXR1cm4gISFjb250cm9sPy52YWx1ZSAmJiAhbGluaz8udmFsdWUgPyBlcnJvcnMgOiBudWxsO1xyXG4gIH07XHJcbiJdfQ==