{"version":3,"file":"load-esm.js","sourceRoot":"","sources":["../../../src/lib/utils/load-esm.ts"],"names":[],"mappings":";;;AAAA,SAAgB,aAAa;IAC3B,OAAO,aAAa,CAAC,uBAAuB,CAAC,CAAC;AAChD,CAAC;AAFD,sCAEC;AAED;;GAEG;AACH,IAAI,IAA+D,CAAC;AAEpE;;;;;;;;;;;GAWG;AACH,SAAgB,aAAa,CAAI,UAAwB;IACvD,IAAI,aAAJ,IAAI,cAAJ,IAAI,IAAJ,IAAI,GAAK,IAAI,QAAQ,CAAC,YAAY,EAAE,4BAA4B,CAAoC,EAAC;IAErG,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC;AAC1B,CAAC;AAJD,sCAIC","sourcesContent":["export function ngCompilerCli(): Promise<typeof import('@angular/compiler-cli')> {\n  return loadEsmModule('@angular/compiler-cli');\n}\n\n/**\n * Lazily compiled dynamic import loader function.\n */\nlet load: (<T>(modulePath: string | URL) => Promise<T>) | undefined;\n\n/**\n * This uses a dynamic import to load a module which may be ESM.\n * CommonJS code can load ESM code via a dynamic import. Unfortunately, TypeScript\n * will currently, unconditionally downlevel dynamic import into a require call.\n * require calls cannot load ESM code and will result in a runtime error. To workaround\n * this, a Function constructor is used to prevent TypeScript from changing the dynamic import.\n * Once TypeScript provides support for keeping the dynamic import this workaround can\n * be dropped.\n *\n * @param modulePath The path of the module to load.\n * @returns A Promise that resolves to the dynamically imported module.\n */\nexport function loadEsmModule<T>(modulePath: string | URL): Promise<T> {\n  load ??= new Function('modulePath', `return import(modulePath);`) as Exclude<typeof load, undefined>;\n\n  return load(modulePath);\n}\n"]}