{"hash":"1b364977b64171286d4aeb594eeb2c80191a0b51","fesm2022":[{"exports":["compareToValidator","earlierThenValidator","etherOrValidator","laterThenValidator","linkToValidator","linkedToValidator","regexpMatchValidator","regexpNotAMatchValidator","requiredWhenValidator"],"facadeModuleId":"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/ngx-validator-pack.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/helpers/date.mjs","/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/ngx-validators.mjs","/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/public-api.mjs","/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/ngx-validator-pack.mjs"],"name":"ngx-validator-pack","type":"chunk","dynamicImports":[],"fileName":"ngx-validator-pack.mjs","implicitlyLoadedBefore":[],"importedBindings":{},"imports":[],"modules":{"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/helpers/date.mjs":{"code":"const prepareToCompare = (date, bufferYears) => {\n    if (date) {\n        const year = date.getFullYear() + (bufferYears || 0);\n        const month = date.getMonth() + 1;\n        const day = date.getDate();\n        return Number.parseInt(`${year}${month.toString().replace.length > 1 ? month : '0' + month}${day.toString().length > 1 ? day : '0' + day}`);\n    }\n    else {\n        return 0;\n    }\n};\nconst compareDates = (date1, date2, operation = '===') => {\n    return compare(date1, date2, operation);\n};\nconst compare = (date1, date2, comparison) => {\n    const operations = {\n        '<': (a, b) => prepareToCompare(a) < prepareToCompare(b),\n        '>': (a, b) => prepareToCompare(a) > prepareToCompare(b),\n        '==': (a, b) => prepareToCompare(a) == prepareToCompare(b),\n        '===': (a, b) => prepareToCompare(a) === prepareToCompare(b),\n        '<=': (a, b) => prepareToCompare(a) <= prepareToCompare(b),\n        '>=': (a, b) => prepareToCompare(a) >= prepareToCompare(b),\n    };\n    return operations[comparison](date1, date2);\n};","originalLength":5206,"removedExports":[],"renderedExports":["prepareToCompare","compareDates"],"renderedLength":1045},"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/ngx-validators.mjs":{"code":"/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n */\n/**\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\n *\n * @param {RegExp}                    - Regular expression to check\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst regexpMatchValidator = (regexp, errorName, error) => (control) => {\n    error = error || 'This control matched a given regular expression.';\n    const errors = typeof error === 'string' ? { [errorName || 'regexpValidator']: error } : error;\n    return !control.value || regexp.test(control.value) ? null : errors;\n};\n/**\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\n *\n * @param {RegExp}                    - Regular expression to check\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst regexpNotAMatchValidator = (regexp, errorName, error) => (control) => {\n    error = error || 'This control matched a given regular expression.';\n    const errors = typeof error === 'string' ? { [errorName || 'regexpValidator']: error } : error;\n    return !control.value || !regexp.test(control.value) ? null : errors;\n};\n/**\n * Checks if the date in the given FromControl / AbstractControl is earlier then\n * the value in the specified FromControl / AbstractControl\n *\n * @param {AbstractControl}           - AbstractControl to preform the check against\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst earlierThenValidator = (date, errorName, error) => (control) => {\n    error = error || `This control must have a value earlier then ${date?.value}.`;\n    const errors = typeof error === 'string' ? { [errorName || 'earlierThen']: error } : error;\n    return prepareToCompare(control?.value) < prepareToCompare(date?.value) ? null : errors;\n};\n/**\n* Checks if the date in the given FromControl / AbstractControl is greater then\n* the value in the specified FromControl / AbstractControl\n*\n* @param {AbstractControl}           - AbstractControl to preform the check against\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst laterThenValidator = (date, errorName, error) => (control) => {\n    error = error || `This control must have a value later then ${date?.value}.`;\n    const errors = typeof error === 'string' ? { [errorName || 'laterThen']: error } : error;\n    return prepareToCompare(control?.value) > prepareToCompare(date?.value) ? null : errors;\n};\n/**\n* Compares the date values of the given FromControl / AbstractControl and\n* specified FromControl / AbstractControl\n*\n* @param {string}                    - name of the filed to compare against\n* @param {ComparisonOperations}      - comparison to preform\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst compareToValidator = (filedName, comparison, errorName, error) => (control) => {\n    const date = control.parent?.get(filedName)?.value;\n    error = error || `Value comparison with ${date?.value} failed.`;\n    const errors = typeof error === 'string' ? { [errorName || 'dateComparison']: error } : error;\n    return control.value && date && compareDates(control.value, date, comparison) ? null : errors;\n};\n/**\n* Returns a validation error if a condition is met\n*\n* @param {Function | boolean}        - conditional function or a boolean value\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst requiredWhenValidator = (conditional, errorName, error) => (control) => {\n    error = error || 'This control has a conditional set on it.';\n    const errors = typeof error === 'string' ? { [errorName || 'requiredWhen']: error } : error;\n    const outcome = typeof conditional === 'function' ? conditional() : conditional;\n    return !control.value || !outcome ? null : errors;\n};\n/**\n* Returns a validation error if a given FromControl / AbstractControl has no value\n* and specified FromControl / AbstractControl has it\n*\n* @param {string}                    - name of the FromControl / AbstractControl to link to\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst linkToValidator = (linkTo, errorName, error) => (control) => {\n    error = error || `This control has a link to ${linkTo}.`;\n    const errors = typeof error === 'string' ? { [errorName || 'linkTo']: error } : error;\n    const linkedTo = control.parent?.get(linkTo);\n    return !control?.value && !!linkedTo?.value ? errors : null;\n};\n/**\n* Returns a validation error if a given FromControl / AbstractControl has a value\n* and specified FromControl / AbstractControl does not\n*\n* @param {string}                    - name of the FromControl / AbstractControl\n*                                      which a given FromControl / AbstractControl is linked to\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst linkedToValidator = (linkedTo, errorName, error) => (control) => {\n    error = error || `This control is linked to ${linkedTo}.`;\n    const errors = typeof error === 'string' ? { [errorName || 'linkTo']: error } : error;\n    const link = control.parent?.get(linkedTo);\n    return control?.value && !link?.value ? errors : null;\n};\n/**\n* Returns a validation error if a nether the given FromControl / AbstractControl nor\n* the specified FromControl / AbstractControl has values\n*\n* @param {AbstractControl}           - AbstractControl to preform the check against\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst etherOrValidator = (toCheck, errorName, error) => (control) => {\n    error = error || `Ether this control or ${toCheck} has to have value.`;\n    const errors = typeof error === 'string' ? { [errorName || 'etherOr']: error } : error;\n    const check = control.parent?.get(toCheck);\n    if (!control?.value && !check?.value) {\n        check.setErrors({\n            [errorName || 'etherOr']: error,\n        });\n        return errors;\n    }\n    else {\n        if (check) {\n            check.setErrors(null);\n        }\n        return null;\n    }\n};","originalLength":26338,"removedExports":[],"renderedExports":["regexpMatchValidator","regexpNotAMatchValidator","earlierThenValidator","laterThenValidator","compareToValidator","requiredWhenValidator","linkToValidator","linkedToValidator","etherOrValidator"],"renderedLength":7535},"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/public-api.mjs":{"code":"/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n *\n * Public API Surface of ngx-validator-pack\n */","originalLength":991,"removedExports":[],"renderedExports":[],"renderedLength":238},"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/ngx-validator-pack.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":528,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"const prepareToCompare = (date, bufferYears) => {\n    if (date) {\n        const year = date.getFullYear() + (bufferYears || 0);\n        const month = date.getMonth() + 1;\n        const day = date.getDate();\n        return Number.parseInt(`${year}${month.toString().replace.length > 1 ? month : '0' + month}${day.toString().length > 1 ? day : '0' + day}`);\n    }\n    else {\n        return 0;\n    }\n};\nconst compareDates = (date1, date2, operation = '===') => {\n    return compare(date1, date2, operation);\n};\nconst compare = (date1, date2, comparison) => {\n    const operations = {\n        '<': (a, b) => prepareToCompare(a) < prepareToCompare(b),\n        '>': (a, b) => prepareToCompare(a) > prepareToCompare(b),\n        '==': (a, b) => prepareToCompare(a) == prepareToCompare(b),\n        '===': (a, b) => prepareToCompare(a) === prepareToCompare(b),\n        '<=': (a, b) => prepareToCompare(a) <= prepareToCompare(b),\n        '>=': (a, b) => prepareToCompare(a) >= prepareToCompare(b),\n    };\n    return operations[comparison](date1, date2);\n};\n\n/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n */\n/**\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\n *\n * @param {RegExp}                    - Regular expression to check\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst regexpMatchValidator = (regexp, errorName, error) => (control) => {\n    error = error || 'This control matched a given regular expression.';\n    const errors = typeof error === 'string' ? { [errorName || 'regexpValidator']: error } : error;\n    return !control.value || regexp.test(control.value) ? null : errors;\n};\n/**\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\n *\n * @param {RegExp}                    - Regular expression to check\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst regexpNotAMatchValidator = (regexp, errorName, error) => (control) => {\n    error = error || 'This control matched a given regular expression.';\n    const errors = typeof error === 'string' ? { [errorName || 'regexpValidator']: error } : error;\n    return !control.value || !regexp.test(control.value) ? null : errors;\n};\n/**\n * Checks if the date in the given FromControl / AbstractControl is earlier then\n * the value in the specified FromControl / AbstractControl\n *\n * @param {AbstractControl}           - AbstractControl to preform the check against\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst earlierThenValidator = (date, errorName, error) => (control) => {\n    error = error || `This control must have a value earlier then ${date?.value}.`;\n    const errors = typeof error === 'string' ? { [errorName || 'earlierThen']: error } : error;\n    return prepareToCompare(control?.value) < prepareToCompare(date?.value) ? null : errors;\n};\n/**\n* Checks if the date in the given FromControl / AbstractControl is greater then\n* the value in the specified FromControl / AbstractControl\n*\n* @param {AbstractControl}           - AbstractControl to preform the check against\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst laterThenValidator = (date, errorName, error) => (control) => {\n    error = error || `This control must have a value later then ${date?.value}.`;\n    const errors = typeof error === 'string' ? { [errorName || 'laterThen']: error } : error;\n    return prepareToCompare(control?.value) > prepareToCompare(date?.value) ? null : errors;\n};\n/**\n* Compares the date values of the given FromControl / AbstractControl and\n* specified FromControl / AbstractControl\n*\n* @param {string}                    - name of the filed to compare against\n* @param {ComparisonOperations}      - comparison to preform\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst compareToValidator = (filedName, comparison, errorName, error) => (control) => {\n    const date = control.parent?.get(filedName)?.value;\n    error = error || `Value comparison with ${date?.value} failed.`;\n    const errors = typeof error === 'string' ? { [errorName || 'dateComparison']: error } : error;\n    return control.value && date && compareDates(control.value, date, comparison) ? null : errors;\n};\n/**\n* Returns a validation error if a condition is met\n*\n* @param {Function | boolean}        - conditional function or a boolean value\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst requiredWhenValidator = (conditional, errorName, error) => (control) => {\n    error = error || 'This control has a conditional set on it.';\n    const errors = typeof error === 'string' ? { [errorName || 'requiredWhen']: error } : error;\n    const outcome = typeof conditional === 'function' ? conditional() : conditional;\n    return !control.value || !outcome ? null : errors;\n};\n/**\n* Returns a validation error if a given FromControl / AbstractControl has no value\n* and specified FromControl / AbstractControl has it\n*\n* @param {string}                    - name of the FromControl / AbstractControl to link to\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst linkToValidator = (linkTo, errorName, error) => (control) => {\n    error = error || `This control has a link to ${linkTo}.`;\n    const errors = typeof error === 'string' ? { [errorName || 'linkTo']: error } : error;\n    const linkedTo = control.parent?.get(linkTo);\n    return !control?.value && !!linkedTo?.value ? errors : null;\n};\n/**\n* Returns a validation error if a given FromControl / AbstractControl has a value\n* and specified FromControl / AbstractControl does not\n*\n* @param {string}                    - name of the FromControl / AbstractControl\n*                                      which a given FromControl / AbstractControl is linked to\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst linkedToValidator = (linkedTo, errorName, error) => (control) => {\n    error = error || `This control is linked to ${linkedTo}.`;\n    const errors = typeof error === 'string' ? { [errorName || 'linkTo']: error } : error;\n    const link = control.parent?.get(linkedTo);\n    return control?.value && !link?.value ? errors : null;\n};\n/**\n* Returns a validation error if a nether the given FromControl / AbstractControl nor\n* the specified FromControl / AbstractControl has values\n*\n* @param {AbstractControl}           - AbstractControl to preform the check against\n* @param {string}                    - optional parameter representing error name\n* @param {ValidationErrors | string} - optional parameter representing error value\n* @returns {ValidationErrors | null} - Validation error\n*/\nconst etherOrValidator = (toCheck, errorName, error) => (control) => {\n    error = error || `Ether this control or ${toCheck} has to have value.`;\n    const errors = typeof error === 'string' ? { [errorName || 'etherOr']: error } : error;\n    const check = control.parent?.get(toCheck);\n    if (!control?.value && !check?.value) {\n        check.setErrors({\n            [errorName || 'etherOr']: error,\n        });\n        return errors;\n    }\n    else {\n        if (check) {\n            check.setErrors(null);\n        }\n        return null;\n    }\n};\n\n/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n *\n * Public API Surface of ngx-validator-pack\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { compareToValidator, earlierThenValidator, etherOrValidator, laterThenValidator, linkToValidator, linkedToValidator, regexpMatchValidator, regexpNotAMatchValidator, requiredWhenValidator };\n//# sourceMappingURL=ngx-validator-pack.mjs.map\n","map":null,"preliminaryFileName":"ngx-validator-pack.mjs","sourcemapFileName":"ngx-validator-pack.mjs.map"},{"fileName":"ngx-validator-pack.mjs.map","needsCodeReference":false,"originalFileName":null,"source":"{\"version\":3,\"file\":\"ngx-validator-pack.mjs\",\"sources\":[\"../../../projects/ngx-validator-pack/src/lib/helpers/date.ts\",\"../../../projects/ngx-validator-pack/src/lib/ngx-validators.ts\",\"../../../projects/ngx-validator-pack/src/public-api.ts\",\"../../../projects/ngx-validator-pack/src/ngx-validator-pack.ts\"],\"sourcesContent\":[\"export type ComparisonOperations = '<' | '>' | '==' | '===' | '<=' | '>=';\\n\\nexport const prepareToCompare = (\\n    date: Date | undefined,\\n    bufferYears?: number\\n): number => {\\n    if(date) {\\n        const year = date.getFullYear() + (bufferYears || 0);\\n        const month = date.getMonth() + 1;\\n        const day = date.getDate();\\n        return Number.parseInt(\\n            `${year}${month.toString().replace.length > 1 ? month : '0' + month}${day.toString().length > 1 ? day : '0' + day}`\\n        );\\n    }\\n    else {\\n        return 0;\\n    }\\n} \\n\\nexport const compareDates = (date1: Date, date2: Date, operation: ComparisonOperations = '==='): boolean => {\\n    return compare(date1, date2, operation);\\n}\\n\\nconst compare = (date1: Date, date2: Date, comparison: ComparisonOperations): boolean => {\\n    const operations = {\\n        '<': (a: Date, b: Date) => prepareToCompare(a) < prepareToCompare(b),\\n        '>': (a: Date, b: Date) => prepareToCompare(a) > prepareToCompare(b),\\n        '==': (a: Date, b: Date) => prepareToCompare(a) == prepareToCompare(b),\\n        '===': (a: Date, b: Date) => prepareToCompare(a) === prepareToCompare(b),\\n        '<=': (a: Date, b: Date) => prepareToCompare(a) <= prepareToCompare(b),\\n        '>=': (a: Date, b: Date) => prepareToCompare(a) >= prepareToCompare(b),\\n    }\\n    return operations[comparison](date1, date2);\\n}\",\"/**\\n * @license\\n * Copyright Slavko Mihajlovic All Rights Reserved.\\n *\\n * Use of this source code is governed by an ISC-style license that can be\\n * found at https://www.isc.org/licenses/\\n */\\n\\nimport { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\\nimport { compareDates, ComparisonOperations, prepareToCompare } from './helpers/date';\\n\\n/**\\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\\n * \\n * @param {RegExp}                    - Regular expression to check\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const regexpMatchValidator =\\n  (regexp: RegExp, errorName?: string, error?: ValidationErrors | string): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || 'This control matched a given regular expression.'\\n    const errors: ValidationErrors = \\n        typeof error === 'string' ? { [errorName || 'regexpValidator']: error } : error;\\n  \\n    return !control.value || regexp.test(control.value) ? null : errors;\\n  };\\n\\n/**\\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\\n * \\n * @param {RegExp}                    - Regular expression to check\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\n  export const regexpNotAMatchValidator =\\n  (regexp: RegExp, errorName?: string, error?: ValidationErrors | string): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || 'This control matched a given regular expression.'\\n    const errors: ValidationErrors = \\n        typeof error === 'string' ? { [errorName || 'regexpValidator']: error } : error;\\n  \\n    return !control.value || !regexp.test(control.value) ? null : errors;\\n  };\\n\\n/**\\n * Checks if the date in the given FromControl / AbstractControl is earlier then \\n * the value in the specified FromControl / AbstractControl\\n * \\n * @param {AbstractControl}           - AbstractControl to preform the check against \\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const earlierThenValidator =\\n  (date: AbstractControl, errorName?: string, error?: ValidationErrors | string): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || `This control must have a value earlier then ${date?.value}.`;\\n    const errors: ValidationErrors = \\n        typeof error === 'string' ? { [errorName || 'earlierThen']: error } : error;\\n  \\n    return prepareToCompare(control?.value) < prepareToCompare(date?.value) ? null : errors;\\n  };\\n\\n/**\\n* Checks if the date in the given FromControl / AbstractControl is greater then \\n* the value in the specified FromControl / AbstractControl\\n* \\n* @param {AbstractControl}           - AbstractControl to preform the check against \\n* @param {string}                    - optional parameter representing error name\\n* @param {ValidationErrors | string} - optional parameter representing error value\\n* @returns {ValidationErrors | null} - Validation error\\n*/\\nexport const laterThenValidator =\\n  (date: AbstractControl, errorName?: string, error?: ValidationErrors | string): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || `This control must have a value later then ${date?.value}.`;\\n    const errors: ValidationErrors = \\n        typeof error === 'string' ? { [errorName || 'laterThen']: error } : error;\\n\\n    return prepareToCompare(control?.value) > prepareToCompare(date?.value) ? null : errors;\\n  };\\n\\n/**\\n* Compares the date values of the given FromControl / AbstractControl and\\n* specified FromControl / AbstractControl\\n* \\n* @param {string}                    - name of the filed to compare against \\n* @param {ComparisonOperations}      - comparison to preform\\n* @param {string}                    - optional parameter representing error name\\n* @param {ValidationErrors | string} - optional parameter representing error value\\n* @returns {ValidationErrors | null} - Validation error\\n*/\\nexport const compareToValidator = (\\n  filedName: string, \\n  comparison: ComparisonOperations, \\n  errorName?: string, \\n  error?: ValidationErrors | string): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    const date = control.parent?.get(filedName)?.value;\\n    error = error || `Value comparison with ${date?.value} failed.`;\\n    const errors: ValidationErrors = \\n        typeof error === 'string' ? { [errorName || 'dateComparison']: error } : error;  \\n    return control.value && date && compareDates(control.value, date, comparison) ? null : errors;\\n  };\\n\\n/**\\n* Returns a validation error if a condition is met\\n* \\n* @param {Function | boolean}        - conditional function or a boolean value\\n* @param {string}                    - optional parameter representing error name\\n* @param {ValidationErrors | string} - optional parameter representing error value\\n* @returns {ValidationErrors | null} - Validation error\\n*/\\nexport const requiredWhenValidator =\\n  (\\n    conditional: () => boolean | boolean,\\n    errorName?: string,\\n    error?: ValidationErrors | string\\n  ): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || 'This control has a conditional set on it.';\\n    const errors: ValidationErrors = \\n        typeof error === 'string' ? { [errorName || 'requiredWhen']: error } : error;\\n\\n    const outcome =\\n      typeof conditional === 'function' ? conditional() : conditional;\\n    return !control.value || !outcome ? null : errors;\\n  };\\n\\n/**\\n* Returns a validation error if a given FromControl / AbstractControl has no value\\n* and specified FromControl / AbstractControl has it\\n* \\n* @param {string}                    - name of the FromControl / AbstractControl to link to\\n* @param {string}                    - optional parameter representing error name\\n* @param {ValidationErrors | string} - optional parameter representing error value\\n* @returns {ValidationErrors | null} - Validation error\\n*/\\nexport const linkToValidator =\\n  (linkTo: string, errorName?: string, error?: ValidationErrors | string): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || `This control has a link to ${linkTo}.`;\\n    const errors: ValidationErrors = \\n        typeof error === 'string' ? { [errorName || 'linkTo']: error } : error;\\n  \\n    const linkedTo = control.parent?.get(linkTo);\\n    return !control?.value && !!linkedTo?.value ? errors : null;\\n  };\\n\\n/**\\n* Returns a validation error if a given FromControl / AbstractControl has a value\\n* and specified FromControl / AbstractControl does not\\n* \\n* @param {string}                    - name of the FromControl / AbstractControl \\n*                                      which a given FromControl / AbstractControl is linked to\\n* @param {string}                    - optional parameter representing error name\\n* @param {ValidationErrors | string} - optional parameter representing error value\\n* @returns {ValidationErrors | null} - Validation error\\n*/\\nexport const linkedToValidator =\\n  (linkedTo: string, errorName?: string, error?: ValidationErrors | string): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || `This control is linked to ${linkedTo}.`;\\n    const errors: ValidationErrors = \\n        typeof error === 'string' ? { [errorName || 'linkTo']: error } : error;\\n   \\n    const link = control.parent?.get(linkedTo);\\n    return control?.value && !link?.value ? errors : null;\\n  };\\n\\n\\n/**\\n* Returns a validation error if a nether the given FromControl / AbstractControl nor \\n* the specified FromControl / AbstractControl has values\\n* \\n* @param {AbstractControl}           - AbstractControl to preform the check against \\n* @param {string}                    - optional parameter representing error name\\n* @param {ValidationErrors | string} - optional parameter representing error value\\n* @returns {ValidationErrors | null} - Validation error\\n*/\\nexport const etherOrValidator =\\n  (toCheck: string, errorName?: string, error?: ValidationErrors | string): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || `Ether this control or ${toCheck} has to have value.`;\\n    const errors: ValidationErrors = \\n        typeof error === 'string' ? { [errorName || 'etherOr']: error } : error;\\n  \\n\\n    const check = control.parent?.get(toCheck) as AbstractControl;\\n    if (!control?.value && !check?.value) {\\n      check.setErrors({\\n        [errorName || 'etherOr']: error,\\n      });\\n      return errors;\\n    } else {\\n      if (check) {\\n        check.setErrors(null);\\n      }\\n      return null;\\n    }\\n  };\\n\\n\\n\\n\",\"/**\\n * @license\\n * Copyright Slavko Mihajlovic All Rights Reserved.\\n *\\n * Use of this source code is governed by an ISC-style license that can be\\n * found at https://www.isc.org/licenses/\\n * \\n * Public API Surface of ngx-validator-pack\\n */\\n\\nexport * from './lib/ngx-validators';\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[],\"mappings\":\"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\"}","type":"asset"}]}