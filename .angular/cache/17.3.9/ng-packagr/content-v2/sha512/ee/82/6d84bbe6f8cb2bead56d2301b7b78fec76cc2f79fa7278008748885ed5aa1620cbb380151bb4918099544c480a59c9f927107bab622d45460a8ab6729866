{"hash":"990bdff3765f918bf8a02aa1da6854145a0b2284","fesm2022":[{"exports":["addressValidator","alphabetOnlyValidator","compareToValidator","dateDD_MM_YYYYValidator","dateYYYY_MM_DDValidator","earlierThenValidator","emailValidator","etherOrValidator","iPv4Validator","iPv6Validator","ipAddressValidator","laterThenValidator","linkToValidator","linkedToValidator","noSpecialsValidator","numericsOnlyValidator","passportValidator","passwordValidator","phoneNumberValidator","regexpMatchValidator","regexpNotAMatchValidator","requiredEther","requiredIf","requiredIfNot","requiredWhenValidator","singleSpaceValidator","spaceRestrictionValidator","ssnValidator","timeHH_MM_12Validator","timeHH_MM_24Validator","timeHH_MM_SS_24Validator","urlValidator","zipCodeValidator"],"facadeModuleId":"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/ngx-validator-pack.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/helpers/date.mjs","/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/ngx-validators.mjs","/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/constant/regex.mjs","/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/ngx-prebuilt-validators.mjs","/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/helpers/errors.mjs","/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/ngx-form-group-validators.mjs","/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/public-api.mjs","/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/ngx-validator-pack.mjs"],"name":"ngx-validator-pack","type":"chunk","dynamicImports":[],"fileName":"ngx-validator-pack.mjs","implicitlyLoadedBefore":[],"importedBindings":{},"imports":[],"modules":{"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/helpers/date.mjs":{"code":"const prepareToCompare = (date, bufferYears) => {\n    if (date) {\n        const year = date.getFullYear() + (bufferYears || 0);\n        const month = date.getMonth() + 1;\n        const day = date.getDate();\n        return Number.parseInt(`${year}${month.toString().replace.length > 1 ? month : '0' + month}${day.toString().length > 1 ? day : '0' + day}`);\n    }\n    else {\n        return 0;\n    }\n};\nconst compareDates = (date1, date2, operation = '===') => {\n    return compare(date1, date2, operation);\n};\nconst compare = (date1, date2, comparison) => {\n    const operations = {\n        '<': (a, b) => prepareToCompare(a) < prepareToCompare(b),\n        '>': (a, b) => prepareToCompare(a) > prepareToCompare(b),\n        '==': (a, b) => prepareToCompare(a) == prepareToCompare(b),\n        '===': (a, b) => prepareToCompare(a) === prepareToCompare(b),\n        '<=': (a, b) => prepareToCompare(a) <= prepareToCompare(b),\n        '>=': (a, b) => prepareToCompare(a) >= prepareToCompare(b),\n    };\n    return operations[comparison](date1, date2);\n};","originalLength":5206,"removedExports":[],"renderedExports":["prepareToCompare","compareDates"],"renderedLength":1045},"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/ngx-validators.mjs":{"code":"/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n */\n/**\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\n *\n * @param {RegExp}                    - Regular expression to check\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst regexpMatchValidator = (regexp, errorName, error) => (control) => {\n    error = error || \"This control did not match a given regular expression.\";\n    const errors = typeof error === \"string\"\n        ? { [errorName || \"regexpValidator\"]: error }\n        : error;\n    return !control.value || regexp.test(control.value) ? null : errors;\n};\n/**\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\n *\n * @param {RegExp}                    - Regular expression to check\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst regexpNotAMatchValidator = (regexp, errorName, error) => (control) => {\n    error = error || \"This control matched a given regular expression.\";\n    const errors = typeof error === \"string\"\n        ? { [errorName || \"regexpValidator\"]: error }\n        : error;\n    return !control.value || !regexp.test(control.value) ? null : errors;\n};\n/**\n * Checks if the date in the given FromControl / AbstractControl is earlier then\n * the value in the specified FromControl / AbstractControl\n *\n * @param {AbstractControl}           - AbstractControl to preform the check against\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst earlierThenValidator = (date, errorName, error) => (control) => {\n    error =\n        error || `This control must have a value earlier then ${date?.value}.`;\n    const errors = typeof error === \"string\"\n        ? { [errorName || \"earlierThen\"]: error }\n        : error;\n    return prepareToCompare(control?.value) < prepareToCompare(date?.value)\n        ? null\n        : errors;\n};\n/**\n * Checks if the date in the given FromControl / AbstractControl is greater then\n * the value in the specified FromControl / AbstractControl\n *\n * @param {AbstractControl}           - AbstractControl to preform the check against\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst laterThenValidator = (date, errorName, error) => (control) => {\n    error =\n        error || `This control must have a value later then ${date?.value}.`;\n    const errors = typeof error === \"string\" ? { [errorName || \"laterThen\"]: error } : error;\n    return prepareToCompare(control?.value) > prepareToCompare(date?.value)\n        ? null\n        : errors;\n};\n/**\n * Compares the date values of the given FromControl / AbstractControl and\n * specified FromControl / AbstractControl\n *\n * @param {string}                    - name of the filed to compare against\n * @param {ComparisonOperations}      - comparison to preform\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst compareToValidator = (filedName, comparison, errorName, error) => (control) => {\n    const date = control.parent?.get(filedName)?.value;\n    error = error || `Value comparison with ${date?.value} failed.`;\n    const errors = typeof error === \"string\"\n        ? { [errorName || \"dateComparison\"]: error }\n        : error;\n    return control.value &&\n        date &&\n        compareDates(control.value, date, comparison)\n        ? null\n        : errors;\n};\n/**\n * Returns a validation error if a condition is met\n *\n * @param {Function | boolean}        - conditional function or a boolean value\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst requiredWhenValidator = (conditional, errorName, error) => (control) => {\n    error = error || \"This control has a conditional set on it.\";\n    const errors = typeof error === \"string\"\n        ? { [errorName || \"requiredWhen\"]: error }\n        : error;\n    const outcome = typeof conditional === \"function\" ? conditional() : conditional;\n    return !control.value || !outcome ? null : errors;\n};\n/**\n * Returns a validation error if a given FromControl / AbstractControl has no value\n * and specified FromControl / AbstractControl has it\n *\n * @param {string}                    - name of the FromControl / AbstractControl to link to\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst linkToValidator = (linkTo, errorName, error) => (control) => {\n    error = error || `This control has a link to ${linkTo}.`;\n    const errors = typeof error === \"string\" ? { [errorName || \"linkTo\"]: error } : error;\n    const linkedTo = control.parent?.get(linkTo);\n    return !control?.value && !!linkedTo?.value ? errors : null;\n};\n/**\n * Returns a validation error if a given FromControl / AbstractControl has a value\n * and specified FromControl / AbstractControl does not\n *\n * @param {string}                    - name of the FromControl / AbstractControl\n *                                      which a given FromControl / AbstractControl is linked to\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst linkedToValidator = (linkedTo, errorName, error) => (control) => {\n    error = error || `This control is linked to ${linkedTo}.`;\n    const errors = typeof error === \"string\" ? { [errorName || \"linkTo\"]: error } : error;\n    const link = control.parent?.get(linkedTo);\n    return control?.value && !link?.value ? errors : null;\n};\n/**\n * Returns a validation error if a nether the given FromControl / AbstractControl nor\n * the specified FromControl / AbstractControl has values\n *\n * @param {AbstractControl}           - AbstractControl to preform the check against\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst etherOrValidator = (toCheck, errorName, error) => (control) => {\n    error = error || `Ether this control or ${toCheck} has to have value.`;\n    const errors = typeof error === \"string\" ? { [errorName || \"etherOr\"]: error } : error;\n    const check = control.parent?.get(toCheck);\n    if (check && !control?.value && !check?.value) {\n        check.setErrors({\n            [errorName || \"etherOr\"]: error,\n        });\n        return errors;\n    }\n    else {\n        if (check) {\n            check.setErrors(null);\n        }\n        return null;\n    }\n};","originalLength":27099,"removedExports":[],"renderedExports":["regexpMatchValidator","regexpNotAMatchValidator","earlierThenValidator","laterThenValidator","compareToValidator","requiredWhenValidator","linkToValidator","linkedToValidator","etherOrValidator"],"renderedLength":7759},"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/constant/regex.mjs":{"code":"// Checks id an input in a format of Street number Street Name, City, State ZIP code\nconst address = /^(\\d{1,}) [a-zA-Z0-9\\s]+(\\,)? [a-zA-Z]+(\\,)? [A-Z]{2} [0-9]{5,6}$/;\n// Checks for date format YYYY-MM-dd\nconst dateYYYY_MM_DD = /([12]\\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]))/;\n// Checks for date format  dd-MM-YYYY or dd.MM.YYYY or dd/MM/YYYY\n// with check for leap year\nconst dateDD_MM_YYYY = /^(?:(?:31(\\/|-|\\.)(?:0?[13578]|1[02]))\\1|(?:(?:29|30)(\\/|-|\\.)(?:0?[1,3-9]|1[0-2])\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^(?:29(\\/|-|\\.)0?2\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\d|2[0-8])(\\/|-|\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$/;\n// Checks if input is an email\nconst email = /^(([^<>()[\\]\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n// Checks if input is in a IPv4 format\nconst IPAddressV4 = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;\n// Checks if input is in a IPv6 format\nconst IPAddressV6 = /(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/;\n// Checks if input is in a IPv4 or IPv6 format\nconst IPAddressV4AndV6 = /((^\\s*((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\\s*$)|(^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$))/;\n// Checks if an input consists of letters only\nconst lettersOnly = /^[A-Za-z]+$/;\n// Checks if the input consists of letters, periods, hyphens and spaces\nconst lettersPeriodsHyphensAndSpaces = /^[a-zA-Z\\s.-]+$/;\n// Checks if input contains any special characters\nconst noSpecial = /^[A-Za-z0-9 ]+$/;\n// Checks if an input consists of numbers only\nconst numbersOnly = /^\\d+$/;\n// Checks if input is in passport format\nconst passport = /^[A-PR-WY][1-9]\\d\\s?\\d{4}[1-9]$/;\n// Checks if input consist of at least 1 lowercase letter, 1 uppercase letter,\n// 1 number, 1 special character and has length of at least 8 characters\nconst passwordStrength = /(?=(.*[0-9]))(?=.*[\\!@#$%^&*()\\\\[\\]{}\\-_+=~`|:;\"'<>,./?])(?=.*[a-z])(?=(.*[A-Z]))(?=(.*)).{8,}/;\n// Checks for a (000) 000 0000 phone format\nconst phoneNumber = /^(\\()?[2-9]{1}\\d{2}(\\))?(-|\\s)?\\d{3}(-|\\s)\\d{4}$/;\n// Checks for a single space character\nconst singleSpace = /[\\s]/;\n// Restrict only spaces, spaces at the beginning and end of the field\nconst spaceRestriction = /^\\S$|^\\S[\\s\\S]*\\S$/;\n// Checks if input is in an Social Security Number format\nconst ssn = /^((?!219-09-9999|078-05-1120)(?!666|000|9\\d{2})\\d{3}-(?!00)\\d{2}-(?!0{4})\\d{4})|((?!219 09 9999|078 05 1120)(?!666|000|9\\d{2})\\d{3} (?!00)\\d{2} (?!0{4})\\d{4})|((?!219099999|078051120)(?!666|000|9\\d{2})\\d{3}(?!00)\\d{2}(?!0{4})\\d{4})$/;\n// Checks for Time Format HH:MM 12-hour with optional leading 0\nconst timeHH_MM_12 = /((1[0-2]|0?[1-9]):([0-5][0-9]) ?([AaPp][Mm]))/;\n// Checks for Time Format HH:MM 24-hour with optional leading 0\nconst timeHH_MM_24 = /^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;\n// Checks for Time Format HH:MM:SS 24-hour\nconst timeHH_MM_SS_24 = /(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)/;\n// Checks if input is a url\nconst url = /(http|ftp|https):\\/\\/[\\w-]+(\\.[\\w-]+)+([\\w.,@?^=%&amp;:\\/~+#-]*[\\w@?^=%&amp;\\/~+#-])?/;\n// Checks of a zip code in formats 00000 or 00000-0000\nconst zipCode = /(^\\d{5}$)|(^\\d{5}-\\d{4}$)/;","originalLength":14388,"removedExports":[],"renderedExports":["address","dateYYYY_MM_DD","dateDD_MM_YYYY","email","IPAddressV4","IPAddressV6","IPAddressV4AndV6","lettersOnly","lettersPeriodsHyphensAndSpaces","noSpecial","numbersOnly","passport","passwordStrength","phoneNumber","singleSpace","spaceRestriction","ssn","timeHH_MM_12","timeHH_MM_24","timeHH_MM_SS_24","url","zipCode"],"renderedLength":5019},"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/ngx-prebuilt-validators.mjs":{"code":"/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n */\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a proper address format\n * (Street number Street Name, City, State ZIP code)\n * Example: 3344 W Alameda Avenue, Lakewood, CO 80222\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst addressValidator = (errorName, error) => regexpMatchValidator(address, errorName, (error =\n    \"Please input a value in a format of: Street number Street Name, City, State ZIP code\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl consists of only\n * alphabetic characters.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst alphabetOnlyValidator = (errorName, error) => regexpMatchValidator(lettersOnly, errorName, (error = \"Only alphabetic characters are allowed.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in one of the\n * following formats: dd-MM-YYYY, dd.MM.YYYY or dd/MM/YYYY.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst dateDD_MM_YYYYValidator = (errorName, error) => regexpMatchValidator(dateDD_MM_YYYY, errorName, (error =\n    \"Please input a value one of the following formats: dd-MM-YYYY or dd.MM.YYYY or dd/MM/YYYY.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\n * YYYY-MM-dd.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst dateYYYY_MM_DDValidator = (errorName, error) => regexpMatchValidator(dateYYYY_MM_DD, errorName, (error = \"Please input a value in a format: YYYY-MM-dd.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\n * local-part@domain.com.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst emailValidator = (errorName, error) => regexpMatchValidator(email, errorName, (error = \"Please input a value in a format: local-part@domain.com\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in one of the\n * following formats: x.x.x.x or y:y:y:y:y:y:y:y.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst ipAddressValidator = (errorName, error) => regexpMatchValidator(IPAddressV4AndV6, errorName, (error =\n    \"Please input a value one of the following formats: x.x.x.x or y:y:y:y:y:y:y:y\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\n * x.x.x.x.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst iPv4Validator = (errorName, error) => regexpMatchValidator(IPAddressV4, errorName, (error = \"Please input a value in a format: x.x.x.x\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\n * y:y:y:y:y:y:y:y.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst iPv6Validator = (errorName, error) => regexpMatchValidator(IPAddressV6, errorName, (error = \"Please input a value in a format: y:y:y:y:y:y:y:y\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl consists of only\n * numeric characters.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst numericsOnlyValidator = (errorName, error) => regexpMatchValidator(numbersOnly, errorName, (error = \"Only numeric characters are allowed.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl has any special characters.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst noSpecialsValidator = (errorName, error) => regexpMatchValidator(noSpecial, errorName, (error = \"No special characters are allowed.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a proper passport format\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst passportValidator = (errorName, error) => regexpMatchValidator(passport, errorName, (error = \"Incorrect passport format.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a strong password format\n * (Has at least 1 lowercase letter, 1 uppercase letter, 1 number, 1 special character and has\n * length of at least 8 characters).\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst passwordValidator = (errorName, error) => regexpMatchValidator(passwordStrength, errorName, (error =\n    \"The value has to contain at least 1 lowercase letter, 1 uppercase letter, 1 special character and has a length of 8.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\n * (000) 000 0000.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst phoneNumberValidator = (errorName, error) => regexpMatchValidator(phoneNumber, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl consists of a single space\n * character.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst singleSpaceValidator = (errorName = \"A single space character is not allowed.\", error) => regexpNotAMatchValidator(singleSpace, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl starts or ends with a\n * space character.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst spaceRestrictionValidator = (errorName = \"Value can not start or end with a space character.\", error) => regexpNotAMatchValidator(spaceRestriction, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in one of the\n * following formats: AAA-GGG-SSSS or AAAGGGSSSS.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst ssnValidator = (errorName = \"Please input a value one of the following formats: AAA-GGG-SSSS or AAAGGGSSSS.\", error) => regexpMatchValidator(ssn, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a\n * Time Format HH:MM 12-hour with optional leading 0.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst timeHH_MM_12Validator = (errorName = \"Please input a value in a HH:MM 12-hour format.\", error) => regexpMatchValidator(timeHH_MM_12, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a\n * Time Format HH:MM 24-hour with optional leading 0.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst timeHH_MM_24Validator = (errorName = \"Please input a value in a HH:MM 24-hour format.\", error) => regexpMatchValidator(timeHH_MM_24, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a\n * Time Format HH:MM:SS 24-hour.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst timeHH_MM_SS_24Validator = (errorName = \"Please input a value in a HH:MM:SS 24-hour format.\", error) => regexpMatchValidator(timeHH_MM_SS_24, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a\n * correct url format.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst urlValidator = (errorName = \"Improper URL format.\", error) => regexpMatchValidator(url, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in one of the\n * following formats: 00000 or 00000-0000.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst zipCodeValidator = (errorName = \"Improper zip code format.\", error) => regexpMatchValidator(zipCode, errorName, error);","originalLength":34883,"removedExports":[],"renderedExports":["addressValidator","alphabetOnlyValidator","dateDD_MM_YYYYValidator","dateYYYY_MM_DDValidator","emailValidator","ipAddressValidator","iPv4Validator","iPv6Validator","numericsOnlyValidator","noSpecialsValidator","passportValidator","passwordValidator","phoneNumberValidator","singleSpaceValidator","spaceRestrictionValidator","ssnValidator","timeHH_MM_12Validator","timeHH_MM_24Validator","timeHH_MM_SS_24Validator","urlValidator","zipCodeValidator"],"renderedLength":11020},"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/helpers/errors.mjs":{"code":"const setErrors = (control, error) => {\n    control.setErrors({ ...control.errors, ...error });\n};\nconst removeErrors = (control, keys) => {\n    const remainingErrors = keys.reduce((errors, key) => {\n        delete errors[key];\n        return errors;\n    }, {\n        ...control.errors,\n    });\n    control.setErrors(Object.keys(remainingErrors).length > 0 ? remainingErrors : null);\n};","originalLength":2267,"removedExports":[],"renderedExports":["setErrors","removeErrors"],"renderedLength":386},"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/lib/ngx-form-group-validators.mjs":{"code":"/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n */\nconst requiredIf = (requiredControlName, controlToCheckName) => {\n    return (control) => {\n        const required = control.get(requiredControlName);\n        const toCheck = control.get(controlToCheckName);\n        if (required?.value || !toCheck?.value) {\n            removeErrors(required, ['required']);\n            return null;\n        }\n        else {\n            const errorVal = `Required ${requiredControlName} when having ${controlToCheckName}.`;\n            setErrors(required, { required: errorVal });\n            return { [errorVal]: true };\n        }\n    };\n};\nconst requiredIfNot = (requiredControlName, controlToCheckName) => {\n    return (control) => {\n        const required = control.get(requiredControlName);\n        const toCheck = control.get(controlToCheckName);\n        if (required?.value || toCheck?.value) {\n            removeErrors(required, ['required']);\n            return null;\n        }\n        else {\n            const errorVal = `Required ${requiredControlName} when not having ${controlToCheckName}.`;\n            setErrors(required, { required: errorVal });\n            return { [errorVal]: true };\n        }\n    };\n};\nconst requiredEther = (requiredControlName, controlToCheckName) => {\n    return (control) => {\n        const required = control.get(requiredControlName);\n        const toCheck = control.get(controlToCheckName);\n        if (required?.value || toCheck?.value) {\n            removeErrors(required, ['required']);\n            removeErrors(toCheck, ['required']);\n            return null;\n        }\n        else {\n            const errorVal = `Required either ${requiredControlName} or ${controlToCheckName}.`;\n            setErrors(required, { required: errorVal });\n            setErrors(toCheck, { required: errorVal });\n            return { [errorVal]: true };\n        }\n    };\n};","originalLength":8119,"removedExports":[],"renderedExports":["requiredIf","requiredIfNot","requiredEther"],"renderedLength":2027},"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/public-api.mjs":{"code":"/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n *\n * Public API Surface of ngx-validator-pack\n */","originalLength":1279,"removedExports":[],"renderedExports":[],"renderedLength":238},"/media/bunny/1BC96BC71CFEAECC/InDevelopment/ngx-validator-pack/dist/ngx-validator-pack/esm2022/ngx-validator-pack.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":528,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"const prepareToCompare = (date, bufferYears) => {\n    if (date) {\n        const year = date.getFullYear() + (bufferYears || 0);\n        const month = date.getMonth() + 1;\n        const day = date.getDate();\n        return Number.parseInt(`${year}${month.toString().replace.length > 1 ? month : '0' + month}${day.toString().length > 1 ? day : '0' + day}`);\n    }\n    else {\n        return 0;\n    }\n};\nconst compareDates = (date1, date2, operation = '===') => {\n    return compare(date1, date2, operation);\n};\nconst compare = (date1, date2, comparison) => {\n    const operations = {\n        '<': (a, b) => prepareToCompare(a) < prepareToCompare(b),\n        '>': (a, b) => prepareToCompare(a) > prepareToCompare(b),\n        '==': (a, b) => prepareToCompare(a) == prepareToCompare(b),\n        '===': (a, b) => prepareToCompare(a) === prepareToCompare(b),\n        '<=': (a, b) => prepareToCompare(a) <= prepareToCompare(b),\n        '>=': (a, b) => prepareToCompare(a) >= prepareToCompare(b),\n    };\n    return operations[comparison](date1, date2);\n};\n\n/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n */\n/**\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\n *\n * @param {RegExp}                    - Regular expression to check\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst regexpMatchValidator = (regexp, errorName, error) => (control) => {\n    error = error || \"This control did not match a given regular expression.\";\n    const errors = typeof error === \"string\"\n        ? { [errorName || \"regexpValidator\"]: error }\n        : error;\n    return !control.value || regexp.test(control.value) ? null : errors;\n};\n/**\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\n *\n * @param {RegExp}                    - Regular expression to check\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst regexpNotAMatchValidator = (regexp, errorName, error) => (control) => {\n    error = error || \"This control matched a given regular expression.\";\n    const errors = typeof error === \"string\"\n        ? { [errorName || \"regexpValidator\"]: error }\n        : error;\n    return !control.value || !regexp.test(control.value) ? null : errors;\n};\n/**\n * Checks if the date in the given FromControl / AbstractControl is earlier then\n * the value in the specified FromControl / AbstractControl\n *\n * @param {AbstractControl}           - AbstractControl to preform the check against\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst earlierThenValidator = (date, errorName, error) => (control) => {\n    error =\n        error || `This control must have a value earlier then ${date?.value}.`;\n    const errors = typeof error === \"string\"\n        ? { [errorName || \"earlierThen\"]: error }\n        : error;\n    return prepareToCompare(control?.value) < prepareToCompare(date?.value)\n        ? null\n        : errors;\n};\n/**\n * Checks if the date in the given FromControl / AbstractControl is greater then\n * the value in the specified FromControl / AbstractControl\n *\n * @param {AbstractControl}           - AbstractControl to preform the check against\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst laterThenValidator = (date, errorName, error) => (control) => {\n    error =\n        error || `This control must have a value later then ${date?.value}.`;\n    const errors = typeof error === \"string\" ? { [errorName || \"laterThen\"]: error } : error;\n    return prepareToCompare(control?.value) > prepareToCompare(date?.value)\n        ? null\n        : errors;\n};\n/**\n * Compares the date values of the given FromControl / AbstractControl and\n * specified FromControl / AbstractControl\n *\n * @param {string}                    - name of the filed to compare against\n * @param {ComparisonOperations}      - comparison to preform\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst compareToValidator = (filedName, comparison, errorName, error) => (control) => {\n    const date = control.parent?.get(filedName)?.value;\n    error = error || `Value comparison with ${date?.value} failed.`;\n    const errors = typeof error === \"string\"\n        ? { [errorName || \"dateComparison\"]: error }\n        : error;\n    return control.value &&\n        date &&\n        compareDates(control.value, date, comparison)\n        ? null\n        : errors;\n};\n/**\n * Returns a validation error if a condition is met\n *\n * @param {Function | boolean}        - conditional function or a boolean value\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst requiredWhenValidator = (conditional, errorName, error) => (control) => {\n    error = error || \"This control has a conditional set on it.\";\n    const errors = typeof error === \"string\"\n        ? { [errorName || \"requiredWhen\"]: error }\n        : error;\n    const outcome = typeof conditional === \"function\" ? conditional() : conditional;\n    return !control.value || !outcome ? null : errors;\n};\n/**\n * Returns a validation error if a given FromControl / AbstractControl has no value\n * and specified FromControl / AbstractControl has it\n *\n * @param {string}                    - name of the FromControl / AbstractControl to link to\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst linkToValidator = (linkTo, errorName, error) => (control) => {\n    error = error || `This control has a link to ${linkTo}.`;\n    const errors = typeof error === \"string\" ? { [errorName || \"linkTo\"]: error } : error;\n    const linkedTo = control.parent?.get(linkTo);\n    return !control?.value && !!linkedTo?.value ? errors : null;\n};\n/**\n * Returns a validation error if a given FromControl / AbstractControl has a value\n * and specified FromControl / AbstractControl does not\n *\n * @param {string}                    - name of the FromControl / AbstractControl\n *                                      which a given FromControl / AbstractControl is linked to\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst linkedToValidator = (linkedTo, errorName, error) => (control) => {\n    error = error || `This control is linked to ${linkedTo}.`;\n    const errors = typeof error === \"string\" ? { [errorName || \"linkTo\"]: error } : error;\n    const link = control.parent?.get(linkedTo);\n    return control?.value && !link?.value ? errors : null;\n};\n/**\n * Returns a validation error if a nether the given FromControl / AbstractControl nor\n * the specified FromControl / AbstractControl has values\n *\n * @param {AbstractControl}           - AbstractControl to preform the check against\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst etherOrValidator = (toCheck, errorName, error) => (control) => {\n    error = error || `Ether this control or ${toCheck} has to have value.`;\n    const errors = typeof error === \"string\" ? { [errorName || \"etherOr\"]: error } : error;\n    const check = control.parent?.get(toCheck);\n    if (check && !control?.value && !check?.value) {\n        check.setErrors({\n            [errorName || \"etherOr\"]: error,\n        });\n        return errors;\n    }\n    else {\n        if (check) {\n            check.setErrors(null);\n        }\n        return null;\n    }\n};\n\n// Checks id an input in a format of Street number Street Name, City, State ZIP code\nconst address = /^(\\d{1,}) [a-zA-Z0-9\\s]+(\\,)? [a-zA-Z]+(\\,)? [A-Z]{2} [0-9]{5,6}$/;\n// Checks for date format YYYY-MM-dd\nconst dateYYYY_MM_DD = /([12]\\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01]))/;\n// Checks for date format  dd-MM-YYYY or dd.MM.YYYY or dd/MM/YYYY\n// with check for leap year\nconst dateDD_MM_YYYY = /^(?:(?:31(\\/|-|\\.)(?:0?[13578]|1[02]))\\1|(?:(?:29|30)(\\/|-|\\.)(?:0?[1,3-9]|1[0-2])\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$|^(?:29(\\/|-|\\.)0?2\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\d|2[0-8])(\\/|-|\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2})$/;\n// Checks if input is an email\nconst email = /^(([^<>()[\\]\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n// Checks if input is in a IPv4 format\nconst IPAddressV4 = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;\n// Checks if input is in a IPv6 format\nconst IPAddressV6 = /(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/;\n// Checks if input is in a IPv4 or IPv6 format\nconst IPAddressV4AndV6 = /((^\\s*((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\\s*$)|(^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$))/;\n// Checks if an input consists of letters only\nconst lettersOnly = /^[A-Za-z]+$/;\n// Checks if the input consists of letters, periods, hyphens and spaces\nconst lettersPeriodsHyphensAndSpaces = /^[a-zA-Z\\s.-]+$/;\n// Checks if input contains any special characters\nconst noSpecial = /^[A-Za-z0-9 ]+$/;\n// Checks if an input consists of numbers only\nconst numbersOnly = /^\\d+$/;\n// Checks if input is in passport format\nconst passport = /^[A-PR-WY][1-9]\\d\\s?\\d{4}[1-9]$/;\n// Checks if input consist of at least 1 lowercase letter, 1 uppercase letter,\n// 1 number, 1 special character and has length of at least 8 characters\nconst passwordStrength = /(?=(.*[0-9]))(?=.*[\\!@#$%^&*()\\\\[\\]{}\\-_+=~`|:;\"'<>,./?])(?=.*[a-z])(?=(.*[A-Z]))(?=(.*)).{8,}/;\n// Checks for a (000) 000 0000 phone format\nconst phoneNumber = /^(\\()?[2-9]{1}\\d{2}(\\))?(-|\\s)?\\d{3}(-|\\s)\\d{4}$/;\n// Checks for a single space character\nconst singleSpace = /[\\s]/;\n// Restrict only spaces, spaces at the beginning and end of the field\nconst spaceRestriction = /^\\S$|^\\S[\\s\\S]*\\S$/;\n// Checks if input is in an Social Security Number format\nconst ssn = /^((?!219-09-9999|078-05-1120)(?!666|000|9\\d{2})\\d{3}-(?!00)\\d{2}-(?!0{4})\\d{4})|((?!219 09 9999|078 05 1120)(?!666|000|9\\d{2})\\d{3} (?!00)\\d{2} (?!0{4})\\d{4})|((?!219099999|078051120)(?!666|000|9\\d{2})\\d{3}(?!00)\\d{2}(?!0{4})\\d{4})$/;\n// Checks for Time Format HH:MM 12-hour with optional leading 0\nconst timeHH_MM_12 = /((1[0-2]|0?[1-9]):([0-5][0-9]) ?([AaPp][Mm]))/;\n// Checks for Time Format HH:MM 24-hour with optional leading 0\nconst timeHH_MM_24 = /^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;\n// Checks for Time Format HH:MM:SS 24-hour\nconst timeHH_MM_SS_24 = /(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)/;\n// Checks if input is a url\nconst url = /(http|ftp|https):\\/\\/[\\w-]+(\\.[\\w-]+)+([\\w.,@?^=%&amp;:\\/~+#-]*[\\w@?^=%&amp;\\/~+#-])?/;\n// Checks of a zip code in formats 00000 or 00000-0000\nconst zipCode = /(^\\d{5}$)|(^\\d{5}-\\d{4}$)/;\n\n/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n */\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a proper address format\n * (Street number Street Name, City, State ZIP code)\n * Example: 3344 W Alameda Avenue, Lakewood, CO 80222\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst addressValidator = (errorName, error) => regexpMatchValidator(address, errorName, (error =\n    \"Please input a value in a format of: Street number Street Name, City, State ZIP code\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl consists of only\n * alphabetic characters.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst alphabetOnlyValidator = (errorName, error) => regexpMatchValidator(lettersOnly, errorName, (error = \"Only alphabetic characters are allowed.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in one of the\n * following formats: dd-MM-YYYY, dd.MM.YYYY or dd/MM/YYYY.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst dateDD_MM_YYYYValidator = (errorName, error) => regexpMatchValidator(dateDD_MM_YYYY, errorName, (error =\n    \"Please input a value one of the following formats: dd-MM-YYYY or dd.MM.YYYY or dd/MM/YYYY.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\n * YYYY-MM-dd.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst dateYYYY_MM_DDValidator = (errorName, error) => regexpMatchValidator(dateYYYY_MM_DD, errorName, (error = \"Please input a value in a format: YYYY-MM-dd.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\n * local-part@domain.com.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst emailValidator = (errorName, error) => regexpMatchValidator(email, errorName, (error = \"Please input a value in a format: local-part@domain.com\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in one of the\n * following formats: x.x.x.x or y:y:y:y:y:y:y:y.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst ipAddressValidator = (errorName, error) => regexpMatchValidator(IPAddressV4AndV6, errorName, (error =\n    \"Please input a value one of the following formats: x.x.x.x or y:y:y:y:y:y:y:y\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\n * x.x.x.x.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst iPv4Validator = (errorName, error) => regexpMatchValidator(IPAddressV4, errorName, (error = \"Please input a value in a format: x.x.x.x\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\n * y:y:y:y:y:y:y:y.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst iPv6Validator = (errorName, error) => regexpMatchValidator(IPAddressV6, errorName, (error = \"Please input a value in a format: y:y:y:y:y:y:y:y\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl consists of only\n * numeric characters.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst numericsOnlyValidator = (errorName, error) => regexpMatchValidator(numbersOnly, errorName, (error = \"Only numeric characters are allowed.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl has any special characters.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst noSpecialsValidator = (errorName, error) => regexpMatchValidator(noSpecial, errorName, (error = \"No special characters are allowed.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a proper passport format\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst passportValidator = (errorName, error) => regexpMatchValidator(passport, errorName, (error = \"Incorrect passport format.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a strong password format\n * (Has at least 1 lowercase letter, 1 uppercase letter, 1 number, 1 special character and has\n * length of at least 8 characters).\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst passwordValidator = (errorName, error) => regexpMatchValidator(passwordStrength, errorName, (error =\n    \"The value has to contain at least 1 lowercase letter, 1 uppercase letter, 1 special character and has a length of 8.\"));\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\n * (000) 000 0000.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst phoneNumberValidator = (errorName, error) => regexpMatchValidator(phoneNumber, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl consists of a single space\n * character.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst singleSpaceValidator = (errorName = \"A single space character is not allowed.\", error) => regexpNotAMatchValidator(singleSpace, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl starts or ends with a\n * space character.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst spaceRestrictionValidator = (errorName = \"Value can not start or end with a space character.\", error) => regexpNotAMatchValidator(spaceRestriction, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in one of the\n * following formats: AAA-GGG-SSSS or AAAGGGSSSS.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst ssnValidator = (errorName = \"Please input a value one of the following formats: AAA-GGG-SSSS or AAAGGGSSSS.\", error) => regexpMatchValidator(ssn, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a\n * Time Format HH:MM 12-hour with optional leading 0.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst timeHH_MM_12Validator = (errorName = \"Please input a value in a HH:MM 12-hour format.\", error) => regexpMatchValidator(timeHH_MM_12, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a\n * Time Format HH:MM 24-hour with optional leading 0.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst timeHH_MM_24Validator = (errorName = \"Please input a value in a HH:MM 24-hour format.\", error) => regexpMatchValidator(timeHH_MM_24, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a\n * Time Format HH:MM:SS 24-hour.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst timeHH_MM_SS_24Validator = (errorName = \"Please input a value in a HH:MM:SS 24-hour format.\", error) => regexpMatchValidator(timeHH_MM_SS_24, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in a\n * correct url format.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst urlValidator = (errorName = \"Improper URL format.\", error) => regexpMatchValidator(url, errorName, error);\n/**\n * Checks if a value in the given FromControl / AbstractControl is in one of the\n * following formats: 00000 or 00000-0000.\n *\n * @param {string}                    - optional parameter representing error name\n * @param {ValidationErrors | string} - optional parameter representing error value\n * @returns {ValidationErrors | null} - Validation error\n */\nconst zipCodeValidator = (errorName = \"Improper zip code format.\", error) => regexpMatchValidator(zipCode, errorName, error);\n\nconst setErrors = (control, error) => {\n    control.setErrors({ ...control.errors, ...error });\n};\nconst removeErrors = (control, keys) => {\n    const remainingErrors = keys.reduce((errors, key) => {\n        delete errors[key];\n        return errors;\n    }, {\n        ...control.errors,\n    });\n    control.setErrors(Object.keys(remainingErrors).length > 0 ? remainingErrors : null);\n};\n\n/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n */\nconst requiredIf = (requiredControlName, controlToCheckName) => {\n    return (control) => {\n        const required = control.get(requiredControlName);\n        const toCheck = control.get(controlToCheckName);\n        if (required?.value || !toCheck?.value) {\n            removeErrors(required, ['required']);\n            return null;\n        }\n        else {\n            const errorVal = `Required ${requiredControlName} when having ${controlToCheckName}.`;\n            setErrors(required, { required: errorVal });\n            return { [errorVal]: true };\n        }\n    };\n};\nconst requiredIfNot = (requiredControlName, controlToCheckName) => {\n    return (control) => {\n        const required = control.get(requiredControlName);\n        const toCheck = control.get(controlToCheckName);\n        if (required?.value || toCheck?.value) {\n            removeErrors(required, ['required']);\n            return null;\n        }\n        else {\n            const errorVal = `Required ${requiredControlName} when not having ${controlToCheckName}.`;\n            setErrors(required, { required: errorVal });\n            return { [errorVal]: true };\n        }\n    };\n};\nconst requiredEther = (requiredControlName, controlToCheckName) => {\n    return (control) => {\n        const required = control.get(requiredControlName);\n        const toCheck = control.get(controlToCheckName);\n        if (required?.value || toCheck?.value) {\n            removeErrors(required, ['required']);\n            removeErrors(toCheck, ['required']);\n            return null;\n        }\n        else {\n            const errorVal = `Required either ${requiredControlName} or ${controlToCheckName}.`;\n            setErrors(required, { required: errorVal });\n            setErrors(toCheck, { required: errorVal });\n            return { [errorVal]: true };\n        }\n    };\n};\n\n/**\n * @license\n * Copyright Slavko Mihajlovic All Rights Reserved.\n *\n * Use of this source code is governed by an ISC-style license that can be\n * found at https://www.isc.org/licenses/\n *\n * Public API Surface of ngx-validator-pack\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { addressValidator, alphabetOnlyValidator, compareToValidator, dateDD_MM_YYYYValidator, dateYYYY_MM_DDValidator, earlierThenValidator, emailValidator, etherOrValidator, iPv4Validator, iPv6Validator, ipAddressValidator, laterThenValidator, linkToValidator, linkedToValidator, noSpecialsValidator, numericsOnlyValidator, passportValidator, passwordValidator, phoneNumberValidator, regexpMatchValidator, regexpNotAMatchValidator, requiredEther, requiredIf, requiredIfNot, requiredWhenValidator, singleSpaceValidator, spaceRestrictionValidator, ssnValidator, timeHH_MM_12Validator, timeHH_MM_24Validator, timeHH_MM_SS_24Validator, urlValidator, zipCodeValidator };\n//# sourceMappingURL=ngx-validator-pack.mjs.map\n","map":null,"preliminaryFileName":"ngx-validator-pack.mjs","sourcemapFileName":"ngx-validator-pack.mjs.map"},{"fileName":"ngx-validator-pack.mjs.map","needsCodeReference":false,"originalFileName":null,"source":"{\"version\":3,\"file\":\"ngx-validator-pack.mjs\",\"sources\":[\"../../../projects/ngx-validator-pack/src/lib/helpers/date.ts\",\"../../../projects/ngx-validator-pack/src/lib/ngx-validators.ts\",\"../../../projects/ngx-validator-pack/src/lib/constant/regex.ts\",\"../../../projects/ngx-validator-pack/src/lib/ngx-prebuilt-validators.ts\",\"../../../projects/ngx-validator-pack/src/lib/helpers/errors.ts\",\"../../../projects/ngx-validator-pack/src/lib/ngx-form-group-validators.ts\",\"../../../projects/ngx-validator-pack/src/public-api.ts\",\"../../../projects/ngx-validator-pack/src/ngx-validator-pack.ts\"],\"sourcesContent\":[\"export type ComparisonOperations = '<' | '>' | '==' | '===' | '<=' | '>=';\\n\\nexport const prepareToCompare = (\\n    date: Date | undefined,\\n    bufferYears?: number\\n): number => {\\n    if(date) {\\n        const year = date.getFullYear() + (bufferYears || 0);\\n        const month = date.getMonth() + 1;\\n        const day = date.getDate();\\n        return Number.parseInt(\\n            `${year}${month.toString().replace.length > 1 ? month : '0' + month}${day.toString().length > 1 ? day : '0' + day}`\\n        );\\n    }\\n    else {\\n        return 0;\\n    }\\n} \\n\\nexport const compareDates = (date1: Date, date2: Date, operation: ComparisonOperations = '==='): boolean => {\\n    return compare(date1, date2, operation);\\n}\\n\\nconst compare = (date1: Date, date2: Date, comparison: ComparisonOperations): boolean => {\\n    const operations = {\\n        '<': (a: Date, b: Date) => prepareToCompare(a) < prepareToCompare(b),\\n        '>': (a: Date, b: Date) => prepareToCompare(a) > prepareToCompare(b),\\n        '==': (a: Date, b: Date) => prepareToCompare(a) == prepareToCompare(b),\\n        '===': (a: Date, b: Date) => prepareToCompare(a) === prepareToCompare(b),\\n        '<=': (a: Date, b: Date) => prepareToCompare(a) <= prepareToCompare(b),\\n        '>=': (a: Date, b: Date) => prepareToCompare(a) >= prepareToCompare(b),\\n    }\\n    return operations[comparison](date1, date2);\\n}\",\"/**\\n * @license\\n * Copyright Slavko Mihajlovic All Rights Reserved.\\n *\\n * Use of this source code is governed by an ISC-style license that can be\\n * found at https://www.isc.org/licenses/\\n */\\n\\nimport { AbstractControl, ValidationErrors, ValidatorFn } from \\\"@angular/forms\\\";\\nimport {\\n  compareDates,\\n  ComparisonOperations,\\n  prepareToCompare,\\n} from \\\"./helpers/date\\\";\\n\\n/**\\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\\n *\\n * @param {RegExp}                    - Regular expression to check\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const regexpMatchValidator =\\n  (\\n    regexp: RegExp,\\n    errorName?: string,\\n    error?: ValidationErrors | string\\n  ): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || \\\"This control did not match a given regular expression.\\\";\\n    const errors: ValidationErrors =\\n      typeof error === \\\"string\\\"\\n        ? { [errorName || \\\"regexpValidator\\\"]: error }\\n        : error;\\n\\n    return !control.value || regexp.test(control.value) ? null : errors;\\n  };\\n\\n/**\\n * Preforms a RegEx check on value in the given FromControl / AbstractControl\\n *\\n * @param {RegExp}                    - Regular expression to check\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const regexpNotAMatchValidator =\\n  (\\n    regexp: RegExp,\\n    errorName?: string,\\n    error?: ValidationErrors | string\\n  ): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || \\\"This control matched a given regular expression.\\\";\\n    const errors: ValidationErrors =\\n      typeof error === \\\"string\\\"\\n        ? { [errorName || \\\"regexpValidator\\\"]: error }\\n        : error;\\n\\n    return !control.value || !regexp.test(control.value) ? null : errors;\\n  };\\n\\n/**\\n * Checks if the date in the given FromControl / AbstractControl is earlier then\\n * the value in the specified FromControl / AbstractControl\\n *\\n * @param {AbstractControl}           - AbstractControl to preform the check against\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const earlierThenValidator =\\n  (\\n    date: AbstractControl,\\n    errorName?: string,\\n    error?: ValidationErrors | string\\n  ): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error =\\n      error || `This control must have a value earlier then ${date?.value}.`;\\n    const errors: ValidationErrors =\\n      typeof error === \\\"string\\\"\\n        ? { [errorName || \\\"earlierThen\\\"]: error }\\n        : error;\\n\\n    return prepareToCompare(control?.value) < prepareToCompare(date?.value)\\n      ? null\\n      : errors;\\n  };\\n\\n/**\\n * Checks if the date in the given FromControl / AbstractControl is greater then\\n * the value in the specified FromControl / AbstractControl\\n *\\n * @param {AbstractControl}           - AbstractControl to preform the check against\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const laterThenValidator =\\n  (\\n    date: AbstractControl,\\n    errorName?: string,\\n    error?: ValidationErrors | string\\n  ): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error =\\n      error || `This control must have a value later then ${date?.value}.`;\\n    const errors: ValidationErrors =\\n      typeof error === \\\"string\\\" ? { [errorName || \\\"laterThen\\\"]: error } : error;\\n\\n    return prepareToCompare(control?.value) > prepareToCompare(date?.value)\\n      ? null\\n      : errors;\\n  };\\n\\n/**\\n * Compares the date values of the given FromControl / AbstractControl and\\n * specified FromControl / AbstractControl\\n *\\n * @param {string}                    - name of the filed to compare against\\n * @param {ComparisonOperations}      - comparison to preform\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const compareToValidator =\\n  (\\n    filedName: string,\\n    comparison: ComparisonOperations,\\n    errorName?: string,\\n    error?: ValidationErrors | string\\n  ): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    const date = control.parent?.get(filedName)?.value;\\n    error = error || `Value comparison with ${date?.value} failed.`;\\n    const errors: ValidationErrors =\\n      typeof error === \\\"string\\\"\\n        ? { [errorName || \\\"dateComparison\\\"]: error }\\n        : error;\\n    return control.value &&\\n      date &&\\n      compareDates(control.value, date, comparison)\\n      ? null\\n      : errors;\\n  };\\n\\n/**\\n * Returns a validation error if a condition is met\\n *\\n * @param {Function | boolean}        - conditional function or a boolean value\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const requiredWhenValidator =\\n  (\\n    conditional: () => boolean | boolean,\\n    errorName?: string,\\n    error?: ValidationErrors | string\\n  ): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || \\\"This control has a conditional set on it.\\\";\\n    const errors: ValidationErrors =\\n      typeof error === \\\"string\\\"\\n        ? { [errorName || \\\"requiredWhen\\\"]: error }\\n        : error;\\n\\n    const outcome =\\n      typeof conditional === \\\"function\\\" ? conditional() : conditional;\\n    return !control.value || !outcome ? null : errors;\\n  };\\n\\n/**\\n * Returns a validation error if a given FromControl / AbstractControl has no value\\n * and specified FromControl / AbstractControl has it\\n *\\n * @param {string}                    - name of the FromControl / AbstractControl to link to\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const linkToValidator =\\n  (\\n    linkTo: string,\\n    errorName?: string,\\n    error?: ValidationErrors | string\\n  ): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || `This control has a link to ${linkTo}.`;\\n    const errors: ValidationErrors =\\n      typeof error === \\\"string\\\" ? { [errorName || \\\"linkTo\\\"]: error } : error;\\n\\n    const linkedTo = control.parent?.get(linkTo);\\n    return !control?.value && !!linkedTo?.value ? errors : null;\\n  };\\n\\n/**\\n * Returns a validation error if a given FromControl / AbstractControl has a value\\n * and specified FromControl / AbstractControl does not\\n *\\n * @param {string}                    - name of the FromControl / AbstractControl\\n *                                      which a given FromControl / AbstractControl is linked to\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const linkedToValidator =\\n  (\\n    linkedTo: string,\\n    errorName?: string,\\n    error?: ValidationErrors | string\\n  ): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || `This control is linked to ${linkedTo}.`;\\n    const errors: ValidationErrors =\\n      typeof error === \\\"string\\\" ? { [errorName || \\\"linkTo\\\"]: error } : error;\\n\\n    const link = control.parent?.get(linkedTo);\\n    return control?.value && !link?.value ? errors : null;\\n  };\\n\\n/**\\n * Returns a validation error if a nether the given FromControl / AbstractControl nor\\n * the specified FromControl / AbstractControl has values\\n *\\n * @param {AbstractControl}           - AbstractControl to preform the check against\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const etherOrValidator =\\n  (\\n    toCheck: string,\\n    errorName?: string,\\n    error?: ValidationErrors | string\\n  ): ValidatorFn =>\\n  (control: AbstractControl): ValidationErrors | null => {\\n    error = error || `Ether this control or ${toCheck} has to have value.`;\\n    const errors: ValidationErrors =\\n      typeof error === \\\"string\\\" ? { [errorName || \\\"etherOr\\\"]: error } : error;\\n\\n    const check = control.parent?.get(toCheck) as AbstractControl;\\n    if (check && !control?.value && !check?.value) {\\n      check.setErrors({\\n        [errorName || \\\"etherOr\\\"]: error,\\n      });\\n      return errors;\\n    } else {\\n      if (check) {\\n        check.setErrors(null);\\n      }\\n      return null;\\n    }\\n  };\\n\",\"// Checks id an input in a format of Street number Street Name, City, State ZIP code\\nexport const address = /^(\\\\d{1,}) [a-zA-Z0-9\\\\s]+(\\\\,)? [a-zA-Z]+(\\\\,)? [A-Z]{2} [0-9]{5,6}$/;\\n// Checks for date format YYYY-MM-dd\\nexport const dateYYYY_MM_DD =\\n  /([12]\\\\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\\\\d|3[01]))/;\\n// Checks for date format  dd-MM-YYYY or dd.MM.YYYY or dd/MM/YYYY\\n// with check for leap year\\nexport const dateDD_MM_YYYY =\\n  /^(?:(?:31(\\\\/|-|\\\\.)(?:0?[13578]|1[02]))\\\\1|(?:(?:29|30)(\\\\/|-|\\\\.)(?:0?[1,3-9]|1[0-2])\\\\2))(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$|^(?:29(\\\\/|-|\\\\.)0?2\\\\3(?:(?:(?:1[6-9]|[2-9]\\\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\\\d|2[0-8])(\\\\/|-|\\\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\\\4(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$/;\\n// Checks if input is an email\\nexport const email =\\n  /^(([^<>()[\\\\]\\\\.,;:\\\\s@\\\\\\\"]+(\\\\.[^<>()[\\\\]\\\\.,;:\\\\s@\\\\\\\"]+)*)|(\\\\\\\".+\\\\\\\"))@(([^<>()[\\\\]\\\\.,;:\\\\s@\\\\\\\"]+\\\\.)+[^<>()[\\\\]\\\\.,;:\\\\s@\\\\\\\"]{2,})$/i;\\n// Checks if input is in a IPv4 format\\nexport const IPAddressV4 =\\n  /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;\\n// Checks if input is in a IPv6 format\\nexport const IPAddressV6 =\\n  /(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/;\\n// Checks if input is in a IPv4 or IPv6 format\\nexport const IPAddressV4AndV6 =\\n  /((^\\\\s*((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))\\\\s*$)|(^\\\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)(\\\\.(25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]?\\\\d)){3}))|:)))(%.+)?\\\\s*$))/;\\n// Checks if an input consists of letters only\\nexport const lettersOnly = /^[A-Za-z]+$/;\\n// Checks if the input consists of letters, periods, hyphens and spaces\\nexport const lettersPeriodsHyphensAndSpaces = /^[a-zA-Z\\\\s.-]+$/;\\n// Checks if input contains any special characters\\nexport const noSpecial = /^[A-Za-z0-9 ]+$/;\\n// Checks if an input consists of numbers only\\nexport const numbersOnly = /^\\\\d+$/;\\n// Checks if input is in passport format\\nexport const passport = /^[A-PR-WY][1-9]\\\\d\\\\s?\\\\d{4}[1-9]$/;\\n// Checks if input consist of at least 1 lowercase letter, 1 uppercase letter,\\n// 1 number, 1 special character and has length of at least 8 characters\\nexport const passwordStrength =\\n  /(?=(.*[0-9]))(?=.*[\\\\!@#$%^&*()\\\\\\\\[\\\\]{}\\\\-_+=~`|:;\\\"'<>,./?])(?=.*[a-z])(?=(.*[A-Z]))(?=(.*)).{8,}/;\\n// Checks for a (000) 000 0000 phone format\\nexport const phoneNumber = /^(\\\\()?[2-9]{1}\\\\d{2}(\\\\))?(-|\\\\s)?\\\\d{3}(-|\\\\s)\\\\d{4}$/;\\n// Checks for a single space character\\nexport const singleSpace = /[\\\\s]/;\\n// Restrict only spaces, spaces at the beginning and end of the field\\nexport const spaceRestriction = /^\\\\S$|^\\\\S[\\\\s\\\\S]*\\\\S$/;\\n// Checks if input is in an Social Security Number format\\nexport const ssn =\\n  /^((?!219-09-9999|078-05-1120)(?!666|000|9\\\\d{2})\\\\d{3}-(?!00)\\\\d{2}-(?!0{4})\\\\d{4})|((?!219 09 9999|078 05 1120)(?!666|000|9\\\\d{2})\\\\d{3} (?!00)\\\\d{2} (?!0{4})\\\\d{4})|((?!219099999|078051120)(?!666|000|9\\\\d{2})\\\\d{3}(?!00)\\\\d{2}(?!0{4})\\\\d{4})$/;\\n// Checks for Time Format HH:MM 12-hour with optional leading 0\\nexport const timeHH_MM_12 = /((1[0-2]|0?[1-9]):([0-5][0-9]) ?([AaPp][Mm]))/;\\n// Checks for Time Format HH:MM 24-hour with optional leading 0\\nexport const timeHH_MM_24 = /^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/;\\n// Checks for Time Format HH:MM:SS 24-hour\\nexport const timeHH_MM_SS_24 =\\n  /(?:[01]\\\\d|2[0123]):(?:[012345]\\\\d):(?:[012345]\\\\d)/;\\n// Checks if input is a url\\nexport const url =\\n  /(http|ftp|https):\\\\/\\\\/[\\\\w-]+(\\\\.[\\\\w-]+)+([\\\\w.,@?^=%&amp;:\\\\/~+#-]*[\\\\w@?^=%&amp;\\\\/~+#-])?/;\\n// Checks of a zip code in formats 00000 or 00000-0000\\nexport const zipCode = /(^\\\\d{5}$)|(^\\\\d{5}-\\\\d{4}$)/;\\n\",\"/**\\n * @license\\n * Copyright Slavko Mihajlovic All Rights Reserved.\\n *\\n * Use of this source code is governed by an ISC-style license that can be\\n * found at https://www.isc.org/licenses/\\n */\\n\\nimport { ValidationErrors } from \\\"@angular/forms\\\";\\nimport {\\n  regexpMatchValidator,\\n  regexpNotAMatchValidator,\\n} from \\\"./ngx-validators\\\";\\nimport {\\n  address,\\n  dateDD_MM_YYYY,\\n  dateYYYY_MM_DD,\\n  email,\\n  IPAddressV4,\\n  IPAddressV4AndV6,\\n  IPAddressV6,\\n  lettersOnly,\\n  noSpecial,\\n  numbersOnly,\\n  passport,\\n  passwordStrength,\\n  phoneNumber,\\n  singleSpace,\\n  spaceRestriction,\\n  ssn,\\n  timeHH_MM_12,\\n  timeHH_MM_24,\\n  timeHH_MM_SS_24,\\n  url,\\n  zipCode,\\n} from \\\"./constant/regex\\\";\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a proper address format\\n * (Street number Street Name, City, State ZIP code)\\n * Example: 3344 W Alameda Avenue, Lakewood, CO 80222\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const addressValidator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    address,\\n    errorName,\\n    (error =\\n      \\\"Please input a value in a format of: Street number Street Name, City, State ZIP code\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl consists of only\\n * alphabetic characters.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const alphabetOnlyValidator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    lettersOnly,\\n    errorName,\\n    (error = \\\"Only alphabetic characters are allowed.\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in one of the\\n * following formats: dd-MM-YYYY, dd.MM.YYYY or dd/MM/YYYY.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const dateDD_MM_YYYYValidator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    dateDD_MM_YYYY,\\n    errorName,\\n    (error =\\n      \\\"Please input a value one of the following formats: dd-MM-YYYY or dd.MM.YYYY or dd/MM/YYYY.\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\\n * YYYY-MM-dd.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const dateYYYY_MM_DDValidator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    dateYYYY_MM_DD,\\n    errorName,\\n    (error = \\\"Please input a value in a format: YYYY-MM-dd.\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\\n * local-part@domain.com.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const emailValidator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    email,\\n    errorName,\\n    (error = \\\"Please input a value in a format: local-part@domain.com\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in one of the\\n * following formats: x.x.x.x or y:y:y:y:y:y:y:y.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const ipAddressValidator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    IPAddressV4AndV6,\\n    errorName,\\n    (error =\\n      \\\"Please input a value one of the following formats: x.x.x.x or y:y:y:y:y:y:y:y\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\\n * x.x.x.x.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const iPv4Validator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    IPAddressV4,\\n    errorName,\\n    (error = \\\"Please input a value in a format: x.x.x.x\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\\n * y:y:y:y:y:y:y:y.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const iPv6Validator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    IPAddressV6,\\n    errorName,\\n    (error = \\\"Please input a value in a format: y:y:y:y:y:y:y:y\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl consists of only\\n * numeric characters.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const numericsOnlyValidator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    numbersOnly,\\n    errorName,\\n    (error = \\\"Only numeric characters are allowed.\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl has any special characters.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const noSpecialsValidator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    noSpecial,\\n    errorName,\\n    (error = \\\"No special characters are allowed.\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a proper passport format\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const passportValidator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    passport,\\n    errorName,\\n    (error = \\\"Incorrect passport format.\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a strong password format\\n * (Has at least 1 lowercase letter, 1 uppercase letter, 1 number, 1 special character and has\\n * length of at least 8 characters).\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const passwordValidator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(\\n    passwordStrength,\\n    errorName,\\n    (error =\\n      \\\"The value has to contain at least 1 lowercase letter, 1 uppercase letter, 1 special character and has a length of 8.\\\")\\n  );\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a following format:\\n * (000) 000 0000.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const phoneNumberValidator = (\\n  errorName?: string,\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(phoneNumber, errorName, error);\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl consists of a single space\\n * character.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const singleSpaceValidator = (\\n  errorName: string = \\\"A single space character is not allowed.\\\",\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpNotAMatchValidator(singleSpace, errorName, error);\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl starts or ends with a\\n * space character.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const spaceRestrictionValidator = (\\n  errorName: string = \\\"Value can not start or end with a space character.\\\",\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpNotAMatchValidator(spaceRestriction, errorName, error);\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in one of the\\n * following formats: AAA-GGG-SSSS or AAAGGGSSSS.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const ssnValidator = (\\n  errorName: string = \\\"Please input a value one of the following formats: AAA-GGG-SSSS or AAAGGGSSSS.\\\",\\n  error?: ValidationErrors | string\\n): ValidationErrors | null => regexpMatchValidator(ssn, errorName, error);\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a\\n * Time Format HH:MM 12-hour with optional leading 0.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const timeHH_MM_12Validator = (\\n  errorName: string = \\\"Please input a value in a HH:MM 12-hour format.\\\",\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(timeHH_MM_12, errorName, error);\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a\\n * Time Format HH:MM 24-hour with optional leading 0.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const timeHH_MM_24Validator = (\\n  errorName: string = \\\"Please input a value in a HH:MM 24-hour format.\\\",\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(timeHH_MM_24, errorName, error);\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a\\n * Time Format HH:MM:SS 24-hour.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const timeHH_MM_SS_24Validator = (\\n  errorName: string = \\\"Please input a value in a HH:MM:SS 24-hour format.\\\",\\n  error?: ValidationErrors | string\\n): ValidationErrors | null =>\\n  regexpMatchValidator(timeHH_MM_SS_24, errorName, error);\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in a\\n * correct url format.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const urlValidator = (\\n  errorName: string = \\\"Improper URL format.\\\",\\n  error?: ValidationErrors | string\\n): ValidationErrors | null => regexpMatchValidator(url, errorName, error);\\n\\n/**\\n * Checks if a value in the given FromControl / AbstractControl is in one of the\\n * following formats: 00000 or 00000-0000.\\n *\\n * @param {string}                    - optional parameter representing error name\\n * @param {ValidationErrors | string} - optional parameter representing error value\\n * @returns {ValidationErrors | null} - Validation error\\n */\\nexport const zipCodeValidator = (\\n  errorName: string = \\\"Improper zip code format.\\\",\\n  error?: ValidationErrors | string\\n): ValidationErrors | null => regexpMatchValidator(zipCode, errorName, error);\\n\",\"import { AbstractControl } from \\\"@angular/forms\\\";\\nexport const setErrors = (\\n    control: AbstractControl,\\n    error: { [key: string]: unknown }\\n  ): void => {\\n    control.setErrors({ ...control.errors, ...error });\\n  }\\n  \\nexport const removeErrors = (control: AbstractControl, keys: string[]): void => {\\n    const remainingErrors = keys.reduce(\\n      (errors, key): { [x: string]: unknown } => {\\n        delete errors[key];\\n        return errors;\\n      },\\n      {\\n        ...control.errors,\\n      }\\n    );\\n    control.setErrors(\\n      Object.keys(remainingErrors).length > 0 ? remainingErrors : null\\n    );\\n  }\",\"/**\\n * @license\\n * Copyright Slavko Mihajlovic All Rights Reserved.\\n *\\n * Use of this source code is governed by an ISC-style license that can be\\n * found at https://www.isc.org/licenses/\\n */\\n\\nimport { AbstractControl, ValidationErrors } from \\\"@angular/forms\\\";\\nimport { removeErrors, setErrors } from \\\"./helpers/errors\\\";\\n\\nexport const requiredIf = (\\n  requiredControlName: string,\\n  controlToCheckName: string\\n) => {\\n  return (control: AbstractControl): ValidationErrors | null => {\\n    const required = control.get(requiredControlName) as AbstractControl;\\n    const toCheck = control.get(controlToCheckName) as AbstractControl;\\n    if (required?.value || !toCheck?.value) {\\n      removeErrors(required, ['required']);\\n      return null;\\n    } else {\\n      const errorVal = `Required ${requiredControlName} when having ${controlToCheckName}.`;\\n      setErrors(required, { required: errorVal });\\n      return { [errorVal]: true };\\n    }\\n  };\\n};\\n\\nexport const requiredIfNot = (\\n  requiredControlName: string,\\n  controlToCheckName: string\\n) => {\\n  return (control: AbstractControl): ValidationErrors | null => {\\n    const required = control.get(requiredControlName) as AbstractControl;\\n    const toCheck = control.get(controlToCheckName) as AbstractControl;\\n    if (required?.value || toCheck?.value) {\\n      removeErrors(required, ['required']);\\n      return null;\\n    } else {\\n      const errorVal = `Required ${requiredControlName} when not having ${controlToCheckName}.`;\\n      setErrors(required, { required: errorVal });\\n      return { [errorVal]: true };\\n    }\\n  };\\n};\\n\\nexport const requiredEther = (\\n  requiredControlName: string,\\n  controlToCheckName: string\\n) => {\\n  return (control: AbstractControl): ValidationErrors | null => {\\n    const required = control.get(requiredControlName) as AbstractControl;\\n    const toCheck = control.get(controlToCheckName) as AbstractControl;\\n    if (required?.value || toCheck?.value) {\\n      removeErrors(required, ['required']);\\n      removeErrors(toCheck, ['required']);\\n      return null;\\n    } else {\\n      const errorVal = `Required either ${requiredControlName} or ${controlToCheckName}.`;\\n      setErrors(required, { required: errorVal });\\n      setErrors(toCheck, { required: errorVal });\\n      return { [errorVal]: true };\\n    }\\n  };\\n};\",\"/**\\n * @license\\n * Copyright Slavko Mihajlovic All Rights Reserved.\\n *\\n * Use of this source code is governed by an ISC-style license that can be\\n * found at https://www.isc.org/licenses/\\n * \\n * Public API Surface of ngx-validator-pack\\n */\\n\\nexport * from './lib/ngx-validators';\\nexport * from './lib/ngx-prebuilt-validators';\\nexport * from './lib/ngx-form-group-validators';\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[],\"mappings\":\"AAEO,MAAM,gBAAgB,GAAG,CAC5B,IAAsB,EACtB,WAAoB,KACZ;IACR,IAAG,IAAI,EAAE;AACL,QAAA,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE,IAAI,WAAW,IAAI,CAAC,CAAC,CAAC;QACrD,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;AAClC,QAAA,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QAC3B,OAAO,MAAM,CAAC,QAAQ,CAClB,GAAG,IAAI,CAAA,EAAG,KAAK,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,GAAG,KAAK,GAAG,GAAG,GAAG,KAAK,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC,MAAM,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAE,CAAA,CACtH,CAAC;KACL;SACI;AACD,QAAA,OAAO,CAAC,CAAC;KACZ;AACL,CAAC,CAAA;AAEM,MAAM,YAAY,GAAG,CAAC,KAAW,EAAE,KAAW,EAAE,SAAA,GAAkC,KAAK,KAAa;IACvG,OAAO,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC;AAC5C,CAAC,CAAA;AAED,MAAM,OAAO,GAAG,CAAC,KAAW,EAAE,KAAW,EAAE,UAAgC,KAAa;AACpF,IAAA,MAAM,UAAU,GAAG;AACf,QAAA,GAAG,EAAE,CAAC,CAAO,EAAE,CAAO,KAAK,gBAAgB,CAAC,CAAC,CAAC,GAAG,gBAAgB,CAAC,CAAC,CAAC;AACpE,QAAA,GAAG,EAAE,CAAC,CAAO,EAAE,CAAO,KAAK,gBAAgB,CAAC,CAAC,CAAC,GAAG,gBAAgB,CAAC,CAAC,CAAC;AACpE,QAAA,IAAI,EAAE,CAAC,CAAO,EAAE,CAAO,KAAK,gBAAgB,CAAC,CAAC,CAAC,IAAI,gBAAgB,CAAC,CAAC,CAAC;AACtE,QAAA,KAAK,EAAE,CAAC,CAAO,EAAE,CAAO,KAAK,gBAAgB,CAAC,CAAC,CAAC,KAAK,gBAAgB,CAAC,CAAC,CAAC;AACxE,QAAA,IAAI,EAAE,CAAC,CAAO,EAAE,CAAO,KAAK,gBAAgB,CAAC,CAAC,CAAC,IAAI,gBAAgB,CAAC,CAAC,CAAC;AACtE,QAAA,IAAI,EAAE,CAAC,CAAO,EAAE,CAAO,KAAK,gBAAgB,CAAC,CAAC,CAAC,IAAI,gBAAgB,CAAC,CAAC,CAAC;KACzE,CAAA;IACD,OAAO,UAAU,CAAC,UAAU,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AAChD,CAAC;;ACjCD;;;;;;AAMG;AASH;;;;;;;AAOG;AACU,MAAA,oBAAoB,GAC/B,CACE,MAAc,EACd,SAAkB,EAClB,KAAiC,KAEnC,CAAC,OAAwB,KAA6B;AACpD,IAAA,KAAK,GAAG,KAAK,IAAI,wDAAwD,CAAC;AAC1E,IAAA,MAAM,MAAM,GACV,OAAO,KAAK,KAAK,QAAQ;UACrB,EAAE,CAAC,SAAS,IAAI,iBAAiB,GAAG,KAAK,EAAE;UAC3C,KAAK,CAAC;IAEZ,OAAO,CAAC,OAAO,CAAC,KAAK,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,IAAI,GAAG,MAAM,CAAC;AACtE,EAAE;AAEJ;;;;;;;AAOG;AACU,MAAA,wBAAwB,GACnC,CACE,MAAc,EACd,SAAkB,EAClB,KAAiC,KAEnC,CAAC,OAAwB,KAA6B;AACpD,IAAA,KAAK,GAAG,KAAK,IAAI,kDAAkD,CAAC;AACpE,IAAA,MAAM,MAAM,GACV,OAAO,KAAK,KAAK,QAAQ;UACrB,EAAE,CAAC,SAAS,IAAI,iBAAiB,GAAG,KAAK,EAAE;UAC3C,KAAK,CAAC;IAEZ,OAAO,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,IAAI,GAAG,MAAM,CAAC;AACvE,EAAE;AAEJ;;;;;;;;AAQG;AACU,MAAA,oBAAoB,GAC/B,CACE,IAAqB,EACrB,SAAkB,EAClB,KAAiC,KAEnC,CAAC,OAAwB,KAA6B;IACpD,KAAK;AACH,QAAA,KAAK,IAAI,CAA+C,4CAAA,EAAA,IAAI,EAAE,KAAK,GAAG,CAAC;AACzE,IAAA,MAAM,MAAM,GACV,OAAO,KAAK,KAAK,QAAQ;UACrB,EAAE,CAAC,SAAS,IAAI,aAAa,GAAG,KAAK,EAAE;UACvC,KAAK,CAAC;AAEZ,IAAA,OAAO,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,GAAG,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC;AACrE,UAAE,IAAI;UACJ,MAAM,CAAC;AACb,EAAE;AAEJ;;;;;;;;AAQG;AACU,MAAA,kBAAkB,GAC7B,CACE,IAAqB,EACrB,SAAkB,EAClB,KAAiC,KAEnC,CAAC,OAAwB,KAA6B;IACpD,KAAK;AACH,QAAA,KAAK,IAAI,CAA6C,0CAAA,EAAA,IAAI,EAAE,KAAK,GAAG,CAAC;IACvE,MAAM,MAAM,GACV,OAAO,KAAK,KAAK,QAAQ,GAAG,EAAE,CAAC,SAAS,IAAI,WAAW,GAAG,KAAK,EAAE,GAAG,KAAK,CAAC;AAE5E,IAAA,OAAO,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,GAAG,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC;AACrE,UAAE,IAAI;UACJ,MAAM,CAAC;AACb,EAAE;AAEJ;;;;;;;;;AASG;AACU,MAAA,kBAAkB,GAC7B,CACE,SAAiB,EACjB,UAAgC,EAChC,SAAkB,EAClB,KAAiC,KAEnC,CAAC,OAAwB,KAA6B;AACpD,IAAA,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,SAAS,CAAC,EAAE,KAAK,CAAC;IACnD,KAAK,GAAG,KAAK,IAAI,CAAA,sBAAA,EAAyB,IAAI,EAAE,KAAK,UAAU,CAAC;AAChE,IAAA,MAAM,MAAM,GACV,OAAO,KAAK,KAAK,QAAQ;UACrB,EAAE,CAAC,SAAS,IAAI,gBAAgB,GAAG,KAAK,EAAE;UAC1C,KAAK,CAAC;IACZ,OAAO,OAAO,CAAC,KAAK;QAClB,IAAI;QACJ,YAAY,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,EAAE,UAAU,CAAC;AAC7C,UAAE,IAAI;UACJ,MAAM,CAAC;AACb,EAAE;AAEJ;;;;;;;AAOG;AACU,MAAA,qBAAqB,GAChC,CACE,WAAoC,EACpC,SAAkB,EAClB,KAAiC,KAEnC,CAAC,OAAwB,KAA6B;AACpD,IAAA,KAAK,GAAG,KAAK,IAAI,2CAA2C,CAAC;AAC7D,IAAA,MAAM,MAAM,GACV,OAAO,KAAK,KAAK,QAAQ;UACrB,EAAE,CAAC,SAAS,IAAI,cAAc,GAAG,KAAK,EAAE;UACxC,KAAK,CAAC;AAEZ,IAAA,MAAM,OAAO,GACX,OAAO,WAAW,KAAK,UAAU,GAAG,WAAW,EAAE,GAAG,WAAW,CAAC;AAClE,IAAA,OAAO,CAAC,OAAO,CAAC,KAAK,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,MAAM,CAAC;AACpD,EAAE;AAEJ;;;;;;;;AAQG;AACU,MAAA,eAAe,GAC1B,CACE,MAAc,EACd,SAAkB,EAClB,KAAiC,KAEnC,CAAC,OAAwB,KAA6B;AACpD,IAAA,KAAK,GAAG,KAAK,IAAI,CAA8B,2BAAA,EAAA,MAAM,GAAG,CAAC;IACzD,MAAM,MAAM,GACV,OAAO,KAAK,KAAK,QAAQ,GAAG,EAAE,CAAC,SAAS,IAAI,QAAQ,GAAG,KAAK,EAAE,GAAG,KAAK,CAAC;IAEzE,MAAM,QAAQ,GAAG,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;AAC7C,IAAA,OAAO,CAAC,OAAO,EAAE,KAAK,IAAI,CAAC,CAAC,QAAQ,EAAE,KAAK,GAAG,MAAM,GAAG,IAAI,CAAC;AAC9D,EAAE;AAEJ;;;;;;;;;AASG;AACU,MAAA,iBAAiB,GAC5B,CACE,QAAgB,EAChB,SAAkB,EAClB,KAAiC,KAEnC,CAAC,OAAwB,KAA6B;AACpD,IAAA,KAAK,GAAG,KAAK,IAAI,CAA6B,0BAAA,EAAA,QAAQ,GAAG,CAAC;IAC1D,MAAM,MAAM,GACV,OAAO,KAAK,KAAK,QAAQ,GAAG,EAAE,CAAC,SAAS,IAAI,QAAQ,GAAG,KAAK,EAAE,GAAG,KAAK,CAAC;IAEzE,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC;AAC3C,IAAA,OAAO,OAAO,EAAE,KAAK,IAAI,CAAC,IAAI,EAAE,KAAK,GAAG,MAAM,GAAG,IAAI,CAAC;AACxD,EAAE;AAEJ;;;;;;;;AAQG;AACU,MAAA,gBAAgB,GAC3B,CACE,OAAe,EACf,SAAkB,EAClB,KAAiC,KAEnC,CAAC,OAAwB,KAA6B;AACpD,IAAA,KAAK,GAAG,KAAK,IAAI,CAAyB,sBAAA,EAAA,OAAO,qBAAqB,CAAC;IACvE,MAAM,MAAM,GACV,OAAO,KAAK,KAAK,QAAQ,GAAG,EAAE,CAAC,SAAS,IAAI,SAAS,GAAG,KAAK,EAAE,GAAG,KAAK,CAAC;IAE1E,MAAM,KAAK,GAAG,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,OAAO,CAAoB,CAAC;AAC9D,IAAA,IAAI,KAAK,IAAI,CAAC,OAAO,EAAE,KAAK,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE;QAC7C,KAAK,CAAC,SAAS,CAAC;AACd,YAAA,CAAC,SAAS,IAAI,SAAS,GAAG,KAAK;AAChC,SAAA,CAAC,CAAC;AACH,QAAA,OAAO,MAAM,CAAC;KACf;SAAM;QACL,IAAI,KAAK,EAAE;AACT,YAAA,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SACvB;AACD,QAAA,OAAO,IAAI,CAAC;KACb;AACH;;AC/PF;AACO,MAAM,OAAO,GAAG,mEAAmE,CAAC;AAC3F;AACO,MAAM,cAAc,GACzB,mDAAmD,CAAC;AACtD;AACA;AACO,MAAM,cAAc,GACzB,sUAAsU,CAAC;AACzU;AACO,MAAM,KAAK,GAChB,sHAAsH,CAAC;AACzH;AACO,MAAM,WAAW,GACtB,2GAA2G,CAAC;AAC9G;AACO,MAAM,WAAW,GACtB,qpBAAqpB,CAAC;AACxpB;AACO,MAAM,gBAAgB,GAC3B,irCAAirC,CAAC;AACprC;AACO,MAAM,WAAW,GAAG,aAAa,CAAC;AACzC;AACO,MAAM,8BAA8B,GAAG,iBAAiB,CAAC;AAChE;AACO,MAAM,SAAS,GAAG,iBAAiB,CAAC;AAC3C;AACO,MAAM,WAAW,GAAG,OAAO,CAAC;AACnC;AACO,MAAM,QAAQ,GAAG,iCAAiC,CAAC;AAC1D;AACA;AACO,MAAM,gBAAgB,GAC3B,gGAAgG,CAAC;AACnG;AACO,MAAM,WAAW,GAAG,kDAAkD,CAAC;AAC9E;AACO,MAAM,WAAW,GAAG,MAAM,CAAC;AAClC;AACO,MAAM,gBAAgB,GAAG,oBAAoB,CAAC;AACrD;AACO,MAAM,GAAG,GACd,0OAA0O,CAAC;AAC7O;AACO,MAAM,YAAY,GAAG,+CAA+C,CAAC;AAC5E;AACO,MAAM,YAAY,GAAG,2CAA2C,CAAC;AACxE;AACO,MAAM,eAAe,GAC1B,kDAAkD,CAAC;AACrD;AACO,MAAM,GAAG,GACd,uFAAuF,CAAC;AAC1F;AACO,MAAM,OAAO,GAAG,2BAA2B;;ACvDlD;;;;;;AAMG;AA+BH;;;;;;;AAOG;AACU,MAAA,gBAAgB,GAAG,CAC9B,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,OAAO,EACP,SAAS,GACR,KAAK;IACJ,sFAAsF,GACxF;AAEJ;;;;;;;AAOG;MACU,qBAAqB,GAAG,CACnC,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,WAAW,EACX,SAAS,GACR,KAAK,GAAG,yCAAyC,GAClD;AAEJ;;;;;;;AAOG;AACU,MAAA,uBAAuB,GAAG,CACrC,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,cAAc,EACd,SAAS,GACR,KAAK;IACJ,4FAA4F,GAC9F;AAEJ;;;;;;;AAOG;MACU,uBAAuB,GAAG,CACrC,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,cAAc,EACd,SAAS,GACR,KAAK,GAAG,+CAA+C,GACxD;AAEJ;;;;;;;AAOG;MACU,cAAc,GAAG,CAC5B,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,KAAK,EACL,SAAS,GACR,KAAK,GAAG,yDAAyD,GAClE;AAEJ;;;;;;;AAOG;AACU,MAAA,kBAAkB,GAAG,CAChC,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,gBAAgB,EAChB,SAAS,GACR,KAAK;IACJ,+EAA+E,GACjF;AAEJ;;;;;;;AAOG;MACU,aAAa,GAAG,CAC3B,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,WAAW,EACX,SAAS,GACR,KAAK,GAAG,2CAA2C,GACpD;AAEJ;;;;;;;AAOG;MACU,aAAa,GAAG,CAC3B,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,WAAW,EACX,SAAS,GACR,KAAK,GAAG,mDAAmD,GAC5D;AAEJ;;;;;;;AAOG;MACU,qBAAqB,GAAG,CACnC,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,WAAW,EACX,SAAS,GACR,KAAK,GAAG,sCAAsC,GAC/C;AAEJ;;;;;;AAMG;MACU,mBAAmB,GAAG,CACjC,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,SAAS,EACT,SAAS,GACR,KAAK,GAAG,oCAAoC,GAC7C;AAEJ;;;;;;AAMG;MACU,iBAAiB,GAAG,CAC/B,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,QAAQ,EACR,SAAS,GACR,KAAK,GAAG,4BAA4B,GACrC;AAEJ;;;;;;;;AAQG;AACU,MAAA,iBAAiB,GAAG,CAC/B,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAClB,gBAAgB,EAChB,SAAS,GACR,KAAK;IACJ,sHAAsH,GACxH;AAEJ;;;;;;;AAOG;AACU,MAAA,oBAAoB,GAAG,CAClC,SAAkB,EAClB,KAAiC,KAEjC,oBAAoB,CAAC,WAAW,EAAE,SAAS,EAAE,KAAK,EAAE;AAEtD;;;;;;;AAOG;MACU,oBAAoB,GAAG,CAClC,SAAoB,GAAA,0CAA0C,EAC9D,KAAiC,KAEjC,wBAAwB,CAAC,WAAW,EAAE,SAAS,EAAE,KAAK,EAAE;AAE1D;;;;;;;AAOG;MACU,yBAAyB,GAAG,CACvC,SAAoB,GAAA,oDAAoD,EACxE,KAAiC,KAEjC,wBAAwB,CAAC,gBAAgB,EAAE,SAAS,EAAE,KAAK,EAAE;AAE/D;;;;;;;AAOG;MACU,YAAY,GAAG,CAC1B,SAAoB,GAAA,gFAAgF,EACpG,KAAiC,KACL,oBAAoB,CAAC,GAAG,EAAE,SAAS,EAAE,KAAK,EAAE;AAE1E;;;;;;;AAOG;MACU,qBAAqB,GAAG,CACnC,SAAoB,GAAA,iDAAiD,EACrE,KAAiC,KAEjC,oBAAoB,CAAC,YAAY,EAAE,SAAS,EAAE,KAAK,EAAE;AAEvD;;;;;;;AAOG;MACU,qBAAqB,GAAG,CACnC,SAAoB,GAAA,iDAAiD,EACrE,KAAiC,KAEjC,oBAAoB,CAAC,YAAY,EAAE,SAAS,EAAE,KAAK,EAAE;AAEvD;;;;;;;AAOG;MACU,wBAAwB,GAAG,CACtC,SAAoB,GAAA,oDAAoD,EACxE,KAAiC,KAEjC,oBAAoB,CAAC,eAAe,EAAE,SAAS,EAAE,KAAK,EAAE;AAE1D;;;;;;;AAOG;MACU,YAAY,GAAG,CAC1B,SAAoB,GAAA,sBAAsB,EAC1C,KAAiC,KACL,oBAAoB,CAAC,GAAG,EAAE,SAAS,EAAE,KAAK,EAAE;AAE1E;;;;;;;AAOG;MACU,gBAAgB,GAAG,CAC9B,SAAoB,GAAA,2BAA2B,EAC/C,KAAiC,KACL,oBAAoB,CAAC,OAAO,EAAE,SAAS,EAAE,KAAK;;ACxXrE,MAAM,SAAS,GAAG,CACrB,OAAwB,EACxB,KAAiC,KACzB;AACR,IAAA,OAAO,CAAC,SAAS,CAAC,EAAE,GAAG,OAAO,CAAC,MAAM,EAAE,GAAG,KAAK,EAAE,CAAC,CAAC;AACrD,CAAC,CAAA;AAEI,MAAM,YAAY,GAAG,CAAC,OAAwB,EAAE,IAAc,KAAU;IAC3E,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CACjC,CAAC,MAAM,EAAE,GAAG,KAA8B;AACxC,QAAA,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;AACnB,QAAA,OAAO,MAAM,CAAC;AAChB,KAAC,EACD;QACE,GAAG,OAAO,CAAC,MAAM;AAClB,KAAA,CACF,CAAC;IACF,OAAO,CAAC,SAAS,CACf,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,MAAM,GAAG,CAAC,GAAG,eAAe,GAAG,IAAI,CACjE,CAAC;AACJ,CAAC;;ACrBH;;;;;;AAMG;MAKU,UAAU,GAAG,CACxB,mBAA2B,EAC3B,kBAA0B,KACxB;IACF,OAAO,CAAC,OAAwB,KAA6B;QAC3D,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAoB,CAAC;QACrE,MAAM,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAAoB,CAAC;QACnE,IAAI,QAAQ,EAAE,KAAK,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE;AACtC,YAAA,YAAY,CAAC,QAAQ,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC;AACrC,YAAA,OAAO,IAAI,CAAC;SACb;aAAM;AACL,YAAA,MAAM,QAAQ,GAAG,CAAA,SAAA,EAAY,mBAAmB,CAAgB,aAAA,EAAA,kBAAkB,GAAG,CAAC;YACtF,SAAS,CAAC,QAAQ,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC,CAAC;AAC5C,YAAA,OAAO,EAAE,CAAC,QAAQ,GAAG,IAAI,EAAE,CAAC;SAC7B;AACH,KAAC,CAAC;AACJ,EAAE;MAEW,aAAa,GAAG,CAC3B,mBAA2B,EAC3B,kBAA0B,KACxB;IACF,OAAO,CAAC,OAAwB,KAA6B;QAC3D,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAoB,CAAC;QACrE,MAAM,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAAoB,CAAC;QACnE,IAAI,QAAQ,EAAE,KAAK,IAAI,OAAO,EAAE,KAAK,EAAE;AACrC,YAAA,YAAY,CAAC,QAAQ,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC;AACrC,YAAA,OAAO,IAAI,CAAC;SACb;aAAM;AACL,YAAA,MAAM,QAAQ,GAAG,CAAA,SAAA,EAAY,mBAAmB,CAAoB,iBAAA,EAAA,kBAAkB,GAAG,CAAC;YAC1F,SAAS,CAAC,QAAQ,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC,CAAC;AAC5C,YAAA,OAAO,EAAE,CAAC,QAAQ,GAAG,IAAI,EAAE,CAAC;SAC7B;AACH,KAAC,CAAC;AACJ,EAAE;MAEW,aAAa,GAAG,CAC3B,mBAA2B,EAC3B,kBAA0B,KACxB;IACF,OAAO,CAAC,OAAwB,KAA6B;QAC3D,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAoB,CAAC;QACrE,MAAM,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAAoB,CAAC;QACnE,IAAI,QAAQ,EAAE,KAAK,IAAI,OAAO,EAAE,KAAK,EAAE;AACrC,YAAA,YAAY,CAAC,QAAQ,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC;AACrC,YAAA,YAAY,CAAC,OAAO,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC;AACpC,YAAA,OAAO,IAAI,CAAC;SACb;aAAM;AACL,YAAA,MAAM,QAAQ,GAAG,CAAA,gBAAA,EAAmB,mBAAmB,CAAO,IAAA,EAAA,kBAAkB,GAAG,CAAC;YACpF,SAAS,CAAC,QAAQ,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC,CAAC;YAC5C,SAAS,CAAC,OAAO,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC,CAAC;AAC3C,YAAA,OAAO,EAAE,CAAC,QAAQ,GAAG,IAAI,EAAE,CAAC;SAC7B;AACH,KAAC,CAAC;AACJ;;ACjEA;;;;;;;;AAQG;;ACRH;;AAEG;;;;\"}","type":"asset"}]}